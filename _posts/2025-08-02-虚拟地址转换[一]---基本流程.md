---
date: 2025-08-02
layout: post
title: 虚拟地址转换[一] - 基本流程
categories: Linux
tags: [Linux, 内存, 虚拟地址] 
---

转载：[虚拟地址转换[一] - 基本流程](https://zhuanlan.zhihu.com/p/65298260)

在`Linux`，`Windows`等操作系统中，为什么不直接使用`Physical Address`（物理地址），而要用`Virtual Address`（虚拟地址）呢（在`Intel`的手册中也被称为`Linear Address`，具体原因请参考这篇文章）？

因为使用虚拟地址可以带来诸多好处：

1.  在支持多进程的系统中，如果各个进程的镜像文件都使用物理地址，则在加载到同一物理内存空间的时候，可能发生冲突。
2.  直接使用物理地址，不便于进行进程地址空间的隔离。
3.  物理内存是有限的，在物理内存整体吃紧的时候，可以让多个进程通过分时复用的方法共享一个物理页面（某个进程需要保存的内容可以暂时`swap`到外部的`disk/flash`），这有点类似于多线程分时复用共享`CPU`的方式。

既然使用虚拟地址，就涉及到将虚拟地址转换为物理地址的过程，这需要`MMU`（`Memory Management Unit`）和页表（`page table`）的共同参与。

#### 🧩 `MMU`

`MMU`是处理器/核（`processer`）中的一个硬件单元，通常每个核有一个`MMU`。`MMU`由两部分组成：`TLB(Translation Lookaside Buffer)`和`table walk unit`。

![img](https://pica.zhimg.com/v2-46fe67ccffed6be67af3083f116a712e_1440w.jpg)

##### 🌲 `Page Table`

`page table`是每个进程独有的，是软件实现的，是存储在`main memory`（比如`DDR`）中的。

🍃 `Address Translation`

因为访问内存中的页表相对耗时，尤其是在现在普遍使用多级页表的情况下，需要多次的内存访问，为了加快访问速度，系统设计人员为`page table`设计了一个硬件缓存 - `TLB`。`CPU`首先会在`TLB`中查找，因为在`TLB`中找起来很快。

`TLB`之所以快：

-   一是因为它含有的`entries`的数目较少
-   二是`TLB`是集成进`CPU`的，它几乎可以按照`CPU`的速度运行。

![img](https://pic4.zhimg.com/v2-0e31467881f34c15094210a3048babbb_1440w.jpg)

如果在`TLB`中找到了含有该虚拟地址的`entry`（`TLB hit`），则可从该`entry`【1】中直接获取对应的物理地址，否则就得去查找当前进程的`page table`（这里其实可能用到`paging structure caches`）。这个时候，组成`MMU`的另一个部分`table walk unit`就被召唤出来了，这里面的`table`就是`page table`。

使用`table walk unit`硬件单元来查找`page table`的方式被称为`hardware TLB miss handling`，通常被`CISC`架构的处理器（比如`IA-32`）所采用。它要在`page table`中查找不到，出现`page fault`的时候才会交由软件（操作系统）处理。

与之相对的通常被`RISC`架构的处理器（比如`Alpha`）采用的`software TLB miss handling`，`TLB miss`后`CPU`就不再参与了，由操作系统通过软件的方式来查找`page table`。使用硬件的方式更快，而使用软件的方式灵活性更强。`IA-64`提供了一种混合模式，可以兼顾两者的优点。

如果在`page table`中找到了该虚拟地址对应的`entry`的`p`（`present`）位是1，说明该虚拟地址对应的物理页面当前驻留在内存中，也就是`page table hit`。找到了还没完，接下来还有两件事要做：

1.  既然是因为在`TLB`里找不到才找到这儿来的，自然要更新`TLB`。
2.  进行权限检测，包括可读/可写/可执行权限，`user/supervisor`模式权限等。如果没有正确的权限，将触发`SIGSEGV`（`Segmentation Fault`）。

如果该虚拟地址对应的`entry`的`p`位是0，就会触发`page fault`，可能有这几种情况：

1.  这个虚拟地址被分配后还从来没有被`access`过（比如`malloc`之后还没有操作分配到的空间，则不会真正分配物理内存）。触发`page fault`后分配物理内存，也就是`demand paging`，有了确定的`demand`了之后才分，然后将`p`位置1。
2.  对应的这个物理页面的内容被换出到外部的`disk/flash`了，这个时候`page table entry`里存的是换出页面在外部`swap area`里暂存的位置，可以将其换回物理内存，再次建立映射，然后将`p`位置1。

关于在`TLB`中具体是怎么找的，在`page table`中又是怎么"walk"的，请看下回分解。

**注**【1】：`entry`有入口的意思，对于`TLB`和单级页表的一个`entry`，就是指向对应`page`的首地址（入口）；对于后文介绍的多级页表的一个`entry`，就是指向下一级页表的首地址（入口）。