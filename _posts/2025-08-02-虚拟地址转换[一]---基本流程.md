---
date: 2025-08-02
layout: post
title: 虚拟地址转换[一] - 基本流程
categories: Linux
tags: [Linux, 内存, 虚拟地址] 
---

转载：[虚拟地址转换[一] - 基本流程](https://zhuanlan.zhihu.com/p/65298260)

在`Linux`，`Windows`等操作系统中，为什么不直接使用`Physical Address`（物理地址），而要用`Virtual Address`（虚拟地址）呢（在`Intel`的手册中也被称为`Linear Address`，具体原因请参考这篇文章）？

因为使用虚拟地址可以带来诸多好处：

1.  在支持多进程的系统中，如果各个进程的镜像文件都使用物理地址，则在加载到同一物理内存空间的时候，可能发生冲突。
2.  直接使用物理地址，不便于进行进程地址空间的隔离。
3.  物理内存是有限的，在物理内存整体吃紧的时候，可以让多个进程通过分时复用的方法共享一个物理页面（某个进程需要保存的内容可以暂时`swap`到外部的`disk/flash`），这有点类似于多线程分时复用共享`CPU`的方式。

既然使用虚拟地址，就涉及到将虚拟地址转换为物理地址的过程，这需要`MMU`（`Memory Management Unit`）和页表（`page table`）的共同参与。

#### 🧩 `MMU`

`MMU`是处理器/核（`processer`）中的一个硬件单元，通常每个核有一个`MMU`。`MMU`由两部分组成：`TLB(Translation Lookaside Buffer)`和`table walk unit`。

![img](https://pica.zhimg.com/v2-46fe67ccffed6be67af3083f116a712e_1440w.jpg)

##### 🌲 `Page Table`

`page table`是每个进程独有的，是软件实现的，是存储在`main memory`（比如`DDR`）中的。

🍃 `Address Translation`

因为访问内存中的页表相对耗时，尤其是在现在普遍使用多级页表的情况下，需要多次的内存访问，为了加快访问速度，系统设计人员为`page table`设计了一个硬件缓存 - `TLB`。`CPU`首先会在`TLB`中查找，因为在`TLB`中找起来很快。

`TLB`之所以快：

-   一是因为它含有的`entries`的数目较少
-   二是`TLB`是集成进`CPU`的，它几乎可以按照`CPU`的速度运行。

![img](https://pic4.zhimg.com/v2-0e31467881f34c15094210a3048babbb_1440w.jpg)

如果在`TLB`中找到了含有该虚拟地址的`entry`（`TLB hit`），则可从该`entry`【1】中直接获取对应的物理地址，否则就得去查找当前进程的`page table`（这里其实可能用到`paging structure caches`）。这个时候，组成`MMU`的另一个部分`table walk unit`就被召唤出来了，这里面的`table`就是`page table`。

使用`table walk unit`硬件单元来查找`page table`的方式被称为`hardware TLB miss handling`，通常被`CISC`架构的处理器（比如`IA-32`）所采用。它要在`page table`中查找不到，出现`page fault`的时候才会交由软件（操作系统）处理。

与之相对的通常被`RISC`架构的处理器（比如`Alpha`）采用的`software TLB miss handling`，`TLB miss`后`CPU`就不再参与了，由操作系统通过软件的方式来查找`page table`。使用硬件的方式更快，而使用软件的方式灵活性更强。`IA-64`提供了一种混合模式，可以兼顾两者的优点。

如果在`page table`中找到了该虚拟地址对应的`entry`的`p`（`present`）位是1，说明该虚拟地址对应的物理页面当前驻留在内存中，也就是`page table hit`。找到了还没完，接下来还有两件事要做：

1.  既然是因为在`TLB`里找不到才找到这儿来的，自然要更新`TLB`。
2.  进行权限检测，包括可读/可写/可执行权限，`user/supervisor`模式权限等。如果没有正确的权限，将触发`SIGSEGV`（`Segmentation Fault`）。

如果该虚拟地址对应的`entry`的`p`位是0，就会触发`page fault`，可能有这几种情况：

1.  这个虚拟地址被分配后还从来没有被`access`过（比如`malloc`之后还没有操作分配到的空间，则不会真正分配物理内存）。触发`page fault`后分配物理内存，也就是`demand paging`，有了确定的`demand`了之后才分，然后将`p`位置1。
2.  对应的这个物理页面的内容被换出到外部的`disk/flash`了，这个时候`page table entry`里存的是换出页面在外部`swap area`里暂存的位置，可以将其换回物理内存，再次建立映射，然后将`p`位置1。

关于在`TLB`中具体是怎么找的，在`page table`中又是怎么"walk"的，请看下回分解。

**注**【1】：`entry`有入口的意思，对于`TLB`和单级页表的一个`entry`，就是指向对应`page`的首地址（入口）；对于后文介绍的多级页表的一个`entry`，就是指向下一级页表的首地址（入口）。

<hr/>

🧭 如何判断当前系统是否启用了`swap`？

✅ 方法一：看当前`swap`是否启用

```bash
$ swapon --show
```

或：

```bash
$ cat /proc/swaps
```

如果没有输出，说明`swap`没启用。否则你会看到：

```bash
$ swapon --show
NAME      TYPE   SIZE USED PRIO
/swapfile file 923.2M   0B   -2
```

📌 如何设置或启用`swap`？

🧱 创建`swap`文件（常见做法）：

```bash
$ sudo fallocate -l 2G /swapfile
$ sudo chmod 600 /swapfile
$ sudo mkswap /swapfile
$ sudo swapon /swapfile
```

验证：

```bash
$ swapon --show
```

让它重启后生效：

```bash
$ echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
```

📌 关键概念解析

✅ `kswapd`是什么？

-   是`Linux`内核的内存回收守护线程之一，内核中表现为`kswapd0`、`kswapd1`等。
-   它在系统空闲或内存水位低时启动，用于**回收页缓存和匿名页**。
-   主要作用：**平衡`zone`的`free pages`数量**，维持水位。

✅ 哪些页会被写入`swap`？

只有满足以下条件的页才会被写入`swap`：

-   是**匿名页**（`anonymous page`），即没有文件映射的内存页，比如`heap`、`stack`、`malloc`出来的内存。
-   当前页不是`active`或者最近没被访问过（`LRU`判定）
-   被回收后不能直接释放的，就会被写入`swapfile`（称为`swap-out`）

🧠 `swapfile`在`kswapd`中的角色

当 `kswapd` 工作流程中发现：

1.  当前`zone`（如`DMA/Normal/HighMem`）低于`low watermark`
2.  `kswapd`开始扫描页表、回收页
3.  回收的页中发现匿名页，无法直接释放
4.  则这些匿名页会被写入`swap`（也就是`/swapfile`）

🔁 后续如果这些页被再次访问，会触发**page fault**，然后**从`/swapfile`中读回内存**（称为**swap-in**）。

🧪 实验看看`swapfile`是否真的生效：

步骤：

```bash
$ sudo apt update
$ sudo apt install stress
# 启动一个吃内存的程序（建议先关闭无关程序）
$ stress --vm 1 --vm-bytes 2G --timeout 30s
```

然后你可以观察`swap`是否被用到了：

```bash
$ watch -n 1 free -h
```

你会看到`Swap:` 那一行的`USED`开始增长，说明`/swapfile`正在被写入。

🔍 内核源码角度（简要）

在内核源码中（如`mm/vmscan.c`），`kswapd`最终会调用到：

```c
shrink_node()
  └── shrink_lruvec()
        └── shrink_list()
              └── shrink_anon()    // 针对匿名页
                    └── try_to_swap_out()
```

而 `try_to_swap_out()`会把匿名页放入`swap`：

```c
swap_entry_t entry = get_swap_page()
set_pte_at(...)  // 把 PTE 设置为 swap entry
```

最终数据写入`/swapfile`或`/dev/sdX swap`设备。

<hr/>

`/etc/fstab` — `File System Table`

-   **作用**：静态配置文件，列出系统启动时自动挂载的文件系统和挂载参数。
-   **位置**：通常是只读的文本文件，系统管理员手动编辑。
-   **内容**：定义了设备、挂载点、文件系统类型、挂载选项等。
-   **作用时间点**：系统启动时由挂载程序读取，决定挂载哪些分区。

`/etc/mtab` — `Mounted File Systems Table`

-   **作用**：记录当前系统中实际挂载的所有文件系统信息，反映实时挂载状态。
-   **内容**：包含设备名、挂载点、文件系统类型、挂载选项等当前使用信息。
-   **更新方式**：
    -   过去是普通文件，由挂载和卸载命令动态更新。
    -   现代`Linux`发行版多用`/proc/mounts`（内核虚拟文件系统）替代`/etc/mtab`，通过软链接实现。
-   **用途**：
    -   命令如`mount`（不带参数时）查看当前挂载状态
    -   `umount`和其他工具使用它判断当前挂载状态



