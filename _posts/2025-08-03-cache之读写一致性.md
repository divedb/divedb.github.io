---
date: 2025-08-03
layout: post
title: cache之读写一致性
categories: Linux
tags: [Linux, 缓存] 
---

![cache之读写一致性](https://picx.zhimg.com/70/v2-c9a8f91da81961b24a020e63ad8fb789_1440w.image?source=172ae18b&biz_tag=Post)

`cache`根据写操作后是否要直接同步到内存，可分为`write back`（稍后同步）和`write through`（立刻同步）。`write through`的方式虽然享受不到写`cache`带来的性能优势，但是还是可以享受读`cache`的好处的，而且其（和内存的）一致性维护也更简单，适用场景包括视频输出等。

而`write back`可以减少不必要的内存写入，减轻总线竞争。现在大部分应用场景下，`cache`多采用`write back`的方式，本文以下的讨论都基于`write back`且只有一个`level`的`cache`。

##### 🌲 `cache`一致性（`coherency`）

`cache`为维护一致性的操作可分为`flush`和`invalidate`。

当`CPU`更改了某条`cache line`中的数据，则该`cache line`中的数据比对应内存中的数据新，此时需要将这条`cache line`标记为`modified`，以便在必要时候（`cache`满了，该`cache line`需要被释放，把位子腾出来给新的`cache line`）将`cache line`中的内容`flush`到内存来同步。

在使用`DMA`的时候，外设（比如网卡）过来的数据会不经过`CPU`直接传送到内存，这时内存中的数据就比对应`cache`中的数据要新，需要使无效（`invalidate`）相关的`cache line`（标记为`dirty`），这样`CPU`下次读取这条`cache line`里的数据的时候，才能知道这些数据不是最新的，得从内存更新。其实某条`cache line`被`invalidate`之后就没有利用价值了，等同于不存在，相当于被清空了，所以也可以算是一种`flush`。

###### 🍃 `cache`读写

首先，需要系统的`cache`是`enable`的状态（在`x86`中由`CR0`寄存器的`CD`位控制），并且要读写的地址所在内存区域的属性是`cachable`的，`CPU`才会首先尝试去`cache`中读写。

`d-cache`（`data cache`）和`i-cache`（`instruction cache`）都是可读的，读操作可分为三种情况：

1.  地址对应的`cache line`不存在，也就是`cache miss`，需要从外部内存读取，然后填充到对应`cache line`（这一过程被称为`cache line fill`）。
2.  地址对应的`cache line`存在但被标记位了`invalidate`，处理方法同1是一样的。
3.  地址对应的`cache line`存在，也就是`cache hit`（`read hit`），这种情况最简单了，直接读`cache line`就可以。

`i-cache`是只读的，只有`d-cache`是可写的（这也是为什么`cache`要划分成`i-cache`和`d-cache`的原因），写操作也可分为三种情况：：

1.  地址对应的`cache line`不存在，可以和读操作一样采用`cache line fill`（这一过程被称为`write allocate`），再改写该`cache line`的内容，然后标记为`modified`状态（`intel`的`P6 family`处理器采用），也可以直接写外部内存（`intel`的`Pentium`处理器采用）。
2.  地址对应的`cache line`存在但被标记位了`invalidate`，同1是一样的。
3.  地址对应的`cache line`存在，即`write hit`，和`read hit`略有不同的是，写完后需要将该`cache line`标记为`modified`。

###### 🍃 相关指令

`cache`一致性的维护由硬件`CPU`自动完成，同时处理器也会提供一些指令，以支持软件对`cache`的操作。以`x86`为例，有四条指令可以对`cache`进行`invalidate/flush`。

1.  全部`invaliate/flush`

-   `WBINVD`，即`write back invalidate`的缩写，具体操作是先将`cache`中标记为`modified`的内容全部`write back`到外部内存，再清空整个`cache`。
-   `INVD`，相比`WBINVD`少了个`write back`的操作，所以没法保证数据一致性，这条指令只在`cache`和外部内存不需要保持一致的情况下使用（如某些测试环境）。

2.   部分`invalidate/flush`

-   `CLFLUSH/CLFLUSHOPT`，即`cache line flush`的缩写，可针对某些`cache lines`单独操作，适用于该`cache line`对应的内存区域之后不会再被访问（`access`）到的情况。

<hr/>

转载：[cache之读写一致性](https://zhuanlan.zhihu.com/p/65245043)

<hr/>

`CPU`写入数据到`L1/L2/L3 cache`时，**不会立刻写回主存**。是否写回主存、何时写回主存，取决于`CPU`的`cache`写策略（`write policy`），主要有以下两种：

🍃 `Write-back`（写回）

这是现代`CPU`默认且最常用的策略。

-   数据先写入`cache`（如`L1`），不立即写回主存。
-   对应的`cache line`被标记为**dirty（脏）**。
-   只有在以下情况之一发生时，才会写回主存：
    -   `cache line`被替换（如`LRU`失效）
    -   `CPU`显式执行`flush`操作（如`CLFLUSH`）
    -   被其他核心通过一致性协议（如`MESI`）访问到，需要同步数据

**优点：** 减少对主存的访问频率，性能更高
**缺点：** 数据可能暂时不在主存中，掉电会丢失未写回的数据（除非通过其他手段备份）

​    ✅ 2. Write-through（直写）

-   每次写入 cache 的同时，**也写入主存**。
-   不存在“脏”cache line。

**优点：** 数据主存始终是最新的
 **缺点：** 每次写都会访问主存，性能较差

**通常用于：**

-   某些嵌入式系统
-   L3 cache 或共享 cache 的某些配置
-   L1 instruction cache（通常是 read-only，不涉及 write）

------

## ⛳ 典型写入流程（Write-back 示例）：

1.  CPU 执行 `mov [addr], val`
2.  若地址命中 L1 cache，就在 L1 修改该 cache line，标为 dirty
3.  等待某个时机再由 L1 写回到 L2 → L3 → 主存（逐层下推）