---
date: 2025-08-12
layout: post
title: 虚拟文件系统
categories: Linux
tags: [Linux, 虚拟文件系统, 深入Linux内核架构] 
---

通常，一个完整的`Linux`系统由成千上万甚至数百万个文件组成，文件中存储着程序、数据和各种信息。为了对文件进行分类和组织，系统采用了层次化的目录结构，并通过多种方式将所需的结构和数据永久保存下来。

每种操作系统至少会提供一种“标准文件系统”，用于以可靠且高效的方式完成所需任务，其功能优劣不一。`Linux`默认附带的`Ext2/3`文件系统就是一种标准文件系统，经过多年的实践证明，它非常健壮且适合日常使用。不过，`Linux`还支持许多其他文件系统，这些系统是专门为`Linux`编写或从其他平台移植而来，均可作为`Ext2`的可行替代方案。

当然，这并不意味着程序员必须针对不同的文件系统编写不同的文件访问代码，因为这与操作系统作为抽象机制的初衷相违背。为了同时支持多种文件系统，并能够访问其他操作系统的文件，`Linux`内核在用户进程与具体文件系统实现之间引入了一个抽象层——虚拟文件系统（`Virtual File System`，简称`VFS`）。

##### 8.1 文件系统类型

文件系统一般可以分为下面3种。

1.  **基于磁盘的文件系统（`Disk-based Filesystem`）** 是在非易失性介质上存储文件的经典方式，确保文件内容的持久性。实际上，许多现代文件系统都是由此演变而来。常见的文件系统如`Ext2/3`、`ReiserFS`、`FAT`以及 `iso9660`都属于这类。它们使用面向块（`block-based`）的存储介质，必须解决如何将文件内容和结构信息存储到层次化目录结构中的问题。在这里，我们暂不关注与底层块设备的通信细节，因为内核中的驱动程序为这些提供了统一的接口。从文件系统的视角来看，底层设备只是一个由存储块组成的列表，而文件系统则负责对该列表进行合理的组织和管理。
2.  **虚拟文件系统（`Virtual Filesystem, VFS`）** 是内核生成的一种特殊文件系统，用于让用户应用程序能够以统一的方式与内核交互。它不依赖于任何硬件设备，因此不需要为其分配实际存储空间。相反，内核创建了一个层次化的文件结构，文件内容动态反映系统的内部状态和信息。比如，当用`ls -l`命令查看`/proc/version`文件时，文件大小显示为 0 字节：

```bash
$ ls -l /proc/version
-r--r--r-- 1 root root 0 May 27 00:36 /proc/version
```

但如果使用`cat`命令读取该文件，内核会实时生成一份关于系统版本和处理器的信息，这些内容来自内核内存中的数据结构：

```bash
$ cat /proc/version
Linux version 2.6.24 (wolfgang@schroedinger) (gcc version 4.2.1 (SUSE Linux))
#1 Tue Jan 29 03:58:03 GMT 2008
```

3.   **网络文件系统（`Network Filesystem`）** 则介于基于磁盘的文件系统和虚拟文件系统之间。它允许用户通过网络访问另一台计算机上的数据。实际上，数据存储在远程系统的硬件设备上，而本地内核无需关心文件的存取细节、数据的组织方式以及硬件通信问题，这些都由远程计算机的内核处理。

尽管如此，内核在处理网络文件系统时，仍需维护文件长度、目录位置等重要元信息，并提供一套统一的函数接口，使用户进程能够执行诸如打开、读取、删除等常见文件操作。由于有虚拟文件系统（`VFS`）这一抽象层，用户空间的进程不会感受到本地文件系统与网络文件系统之间的区别。

##### 🌲 8.2 通用文件模型

虚拟文件系统为不同文件系统提供了统一的方法和抽象，还支持对文件系统中对象（或称文件）进行统一的视图管理。虽然“文件”这一术语看似简单明了，但由于不同文件系统底层实现的差异，其具体语义常常存在许多细微而复杂的区别。并非所有文件系统都支持完全相同的功能，有些操作对于“普通”文件来说必不可少，但对某些特殊对象（如命名管道）则毫无意义。

要定义一个最小的通用模型，以支持所有内核中存在的文件系统的共同功能，实际上是不切实际的。这样做会导致许多文件系统的关键特性被舍弃，或者只能通过特定文件系统的专用接口访问，反而削弱了虚拟抽象层带来的便利。

`VFS`的设计理念正好相反：它提供了一个包含强大文件系统应有组件的结构模型，但该模型只存在于虚拟层面。通过各种对象和函数指针，`VFS`与具体的文件系统进行适配。每个文件系统的实现都必须提供与 VFS 结构配合的接口，以桥接两者之间的差异。

当然，虚拟文件系统的结构并非凭空想象，而是基于经典文件系统的设计。`VFS`的组织结构与`Ext2`文件系统非常相似，这使得处理基于`Ext2`的文件系统时性能优异，因为`Ext2`与`VFS`之间的转换几乎无延迟。对于采用完全不同设计理念的文件系统（如`ReiserFS`或`XFS`）来说，适配难度会更大。

在文件处理过程中，内核空间和用户空间所使用的主要对象不同。对用户程序而言，文件由一个文件描述符标识。该描述符是一个整数，用于在各种文件操作中指代具体文件。文件描述符由内核在打开文件时分配，并且只在分配它的进程内部有效。不同进程可以使用相同数值的文件描述符，但它们指向的文件并不相同；基于同一个文件描述符在进程间共享文件是不可行的。

内核中处理文件的核心对象是`inode`。每个文件和目录都有且仅有一个对应的`inode`，它包含了文件的元数据，如访问权限、最后修改时间等信息，以及指向文件数据的指针。值得注意的是，`inode`本身并不包含文件名，这似乎有些反直觉，因为通常我们会认为文件名是文件的一个重要属性，应当包含在管理文件的对象中。

###### 🍃 8.2.1 `inode`

如何用数据结构表示目录的层次结构呢？如前所述，`inode`是文件实现中的核心概念，同时也用于目录的实现。换句话说，目录本质上也是一种特殊的文件，只不过它需要被特殊地解析。

`inode`的成员大致可以分为两类：

1.  描述文件状态的元数据，比如访问权限、上次修改时间等；
2.  保存文件实际内容的数据段，或者指向数据的指针。对于文本文件来说，这部分存储文本内容。

为了说明如何利用`inode`构造文件系统中的目录层次结构，我们来看内核查找`/usr/bin/emacs`对应`inode`的过程。

查找从根目录`/`的`inode`开始。根目录在系统中总是已知的，并由一个`inode`表示。该`inode`的数据段不包含普通数据，而是存储了根目录下的各个目录项，每个目录项可能代表一个文件或子目录。目录项包含两个信息：

-   该目录项对应的`inode`编号；
-   文件或目录的名称。

系统中每个`inode`都有一个唯一编号，用于标识该`inode`。文件名和`inode`之间的关联正是通过这个编号建立的。

查找过程的第一步是扫描根目录`inode`的数据段，查找名为`usr`的目录项。如果找不到，则返回“文件未找到”错误。找到后，通过该目录项的`inode`编号定位对应的`inode`。

接下来，在`usr`目录对应`inode`的数据段中查找名为`bin`的目录项，获取其`inode`编号并定位`inode`。然后，在`bin`对应`inode`的数据段中查找名为`emacs`的目录项，得到对应文件的`inode`编号。此时找到的`inode`表示的是一个文件而非目录。

图8-2显示了查找结束时的状态，路径中的对象通过指针相互关联。

![](/assets/img/linux/figure8-2.png)

最后找到的`inode`与前面三个目录`inode`不同，前三个`inode`表示目录，其数据段包含目录项列表，而`emacs`文件的`inode`数据段则保存了文件的实际内容。

尽管上述分步查找的基本思想与`VFS`的实际实现相似，但细节上存在差异。比如，实际实现中使用缓存来加速查找，因为频繁打开文件会带来性能损耗。此外，`VFS`还需与底层具体文件系统通信，获取实际的文件信息。

###### 🍃 8.2.2 链接

链接用于在文件系统对象之间建立联系，这突破了传统树形结构的限制。链接主要有两种类型：符号链接和硬链接。

符号链接（软链接）类似于用户程序看来的一种“指针”，它指向某个文件在文件系统中的位置。实际文件可能存在于别处。符号链接和其目标文件之间并不紧密绑定，符号链接本质上是一个目录项，其对应的`inode`中数据段保存着一个指向目标路径的字符串。当目标文件被删除时，符号链接依然存在。每个符号链接都有独立的`inode`。

符号链接可以区分原始文件和链接本身。硬链接则不同，一旦建立硬链接，就无法区分哪个是原文件，哪个是链接。硬链接创建时，目录项直接使用了已有文件的`inode`编号。

删除符号链接相对简单，但硬链接的删除处理则更复杂。假设硬链接`B`与原始文件`A`共享同一个 inode。如果用户删除了文件`A`，通常会释放该`inode`及其数据块，从而释放存储空间。但此时硬链接`B`将失去对文件的访问，这显然不是期望的行为。

为了解决这个问题，`inode`中引入了一个计数器。每创建一个硬链接，计数器加1；每删除一个硬链接或原始文件，计数器减1。只有当计数器减至0，系统才真正删除该`inode`及其数据。