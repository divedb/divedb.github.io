---
date: 2025-08-02
layout: post
title: 虚拟地址转换[二] - 具体实现
categories: Linux
tags: [Linux, 内存, 虚拟地址] 
---

转载：[虚拟地址转换[二] - 具体实现](https://zhuanlan.zhihu.com/p/65348145)

![虚拟地址转换[二] - 具体实现](https://pic1.zhimg.com/70/v2-d1e15f8f380f9a915f8affbccc683878_1440w.image?source=172ae18b&biz_tag=Post)

关于上文提到的“关于在`TLB`中具体是怎么找的，在`page table`中又是怎么"walk"的问题，下面通过一个简单的例子说明一下。

假设当前`CPU`支持的虚拟地址是14位，物理地址是12位，`page size`为64字节（这里要说明一下，通常情况下呢，虚拟地址和物理地址的位数是一样的，但其实并不一定需要一样，因为本来就可以多个虚拟地址指向同一个物理地址嘛）。

不管是虚拟地址还是物理地址，因为最小管理单位都是`page`，在转换过程中，代表页内的偏移地址（`offset`）的低位`bits`部分是不需要参与的，需要转换的只是代表`page`唯一性标识的高位`bits`部分，称作`page number`。由此产生了4个概念：`VPN`（`virtual page number`），`PPN`（`physical page number`），`VPO`（`virtual page offset`）和`PPO`（`physical page offset`）。

![img](https://pic3.zhimg.com/v2-23a970e0c0eb1d726299c62b1d867f70_1440w.jpg)

`VPO`和`PPO`占的`bit`位数为$\log_{2}p$，`p`为`page size`大小，即64，因而`VPO`和`PPO`的值为6。因为所有`pages`都是同样大小的，所`VPO`始终等于`PPO`。

![img](https://pic3.zhimg.com/v2-2ccb1615ae0d72cdc000f1d2774c1d06_1440w.jpg)

虚拟地址中剩下的`bit`位就成了`VPN`，物理地址中剩下的`bit`位就成了`PPN`。

![img](https://pic3.zhimg.com/v2-604e629384d0f464e00f62dd37d14720_1440w.jpg)

假设我们的`TLB`一共有16个entries，是4路组相关（`4-way set associative`）的，则有16/4=4个sets。`TLB`本身是一个硬件缓存，关于`cache`中`way, set, index, tag`的基础概念，如果还不熟悉的，可以参考这两篇文章：“浅谈Cache Memory”和“cache之虚虚实实”。

`TLB Index`（以下简称`TI`）的值为 =2，剩下的`bit`位就成了`TLB Tag`（以下简称`TT`）。

![img](https://picx.zhimg.com/v2-3c52a230e42a2b5f07b2c69c2c27eeff_1440w.jpg)

下面，我们准备读取虚拟地址为`0x0334`处的内容。

1.  将这一地址分割成`VPN`和`VPO`

![img](https://pic3.zhimg.com/v2-395fa9a3023b9f371f8bc2cc7613ac16_1440w.jpg)

2.   将`VPN`分割成`TT`和`TI`

![img](https://pic2.zhimg.com/v2-01acd41ce7c83b3d7f1ed78d5fd0f8d7_1440w.jpg)

3.   使用`TT(0x03)`和`TI (0)`在`TLB`中查找。一个`TLB entry`的构成如下：

![img](https://pic3.zhimg.com/v2-7c828d8b385d3893d2f83203dc28626a_1440w.jpg)

作为`cache`，`TLB index`是用来索引的，不会存储在`TLB entry`中，`TLB entry`中存的只有`tag`，有效位，权限位和内容（对于`TLB`来说就是`PPN`）。

假设现在`TLB`中的内容是这样的（这里为了简化，省略了`permission bits`）：

![img](https://pic3.zhimg.com/v2-7fb9edf3108cd284181f6b75aecced74_1440w.jpg)

虽然在`set/index`为0这一行，找到了`tag`为03的一个`entry`，但这个`entry`中`PPN`是不存在的，整个`entry`目前是`invalid`的，也就是说`TLB miss`了，需要去`page table`中找。

4.   使用`VPN(0x0C)`作为`index`在`page table`中查找。一个只有`one level`的`page table`（单级页表）构成如下：

![img](https://picx.zhimg.com/v2-38721343651dee5d4cf4b6b3d050e855_1440w.jpg)

`index`作为索引，也是不会存储于`page table entry`中的，`PTE`存的只有权限位，有效位和内容（对于`PTE`来说也是`PPN`）。

假设现在的`page table`是这样的（同样为了简化，省略了`permission bits`）：

![img](https://pic2.zhimg.com/v2-8ff492cfa8a0e093cb6804ceb3a03d87_1440w.jpg)

对应的`PTE`（`page table entry`）中的`PPN`不存在，依然是`invalid`的，这将触发一个`page fault`。

实现的细节展开后，上文中的图也可以展开了（只用关注左半部分）

![img](https://pic2.zhimg.com/v2-f95854185a5da15eb93f820e4686d411_1440w.jpg)

对比一下，你可能会发现一个`TLB entry`比一个`page table entry`多了一个`tag`，`TLB`使用的是`tag`比对【1】，而页表使用的是`index`索引，在`PTE`数目很大的情况下这会带来一系列问题，详情请看下回分解。

**注**【1】：如果是`full associative`的`TLB`，则只有`tag`没有`index`；如果是`n-way set associative`的`TLB`，则先通过`index`索引，再进行`tag`比对。