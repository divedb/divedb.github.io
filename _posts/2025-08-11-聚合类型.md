---
date: 2025-08-11
layout: post
title: 聚合类型
categories: C++
tags: [C++, 聚合类型] 
---

聚合类型（`Aggregates`）

初始化是`C++`中一个非常重要且复杂的话题。对象的初始化方式多种多样，`C++11`试图通过引入统一初始化（`uniform initialization`），即使用花括号`{}`，来解决这个问题。遗憾的是，仍有一些情况不能完美支持，甚至会产生令人意外的结果。`C++20`又迈出了一步，努力让初始化形式更统一、更一致，也希望能让初学者更容易上手。

##### 8.1 什么是聚合类型

聚合类型可以是数组或者类。C++20 对聚合类型的定义包括以下限制：

-   类中不能有用户声明的构造函数，也不能有继承来的构造函数。
-   只能包含`public`的非静态数据成员。
-   没有虚函数。
-   没有虚基类。
-   没有私有或受保护的直接基类。

示例：基类可以有用户声明的构造函数

{% raw %}
```cpp
#include <type_traits>

struct B {
  B(int) {}

  int b;
};

struct P : B {
 public:
  int a;
};

int main() {
  static_assert(std::is_aggregate_v<P>);
  P p{{42}, 10};
}
```

{% endraw %}

允许聚合类型拥有基类，是`C++17`带来的更新。`C++14`对聚合的限制也有所放宽：聚合类型的非静态数据成员可以有等号初始化器（`equal initializer`）或花括号初始化器（`braced initializer`），这样我们就可以直接在聚合内部初始化成员，例如：

```cpp
struct Aggregate {
	int a = 5;  // A：等号初始化器
  int b{7};   // B：花括号初始化器
};
```

##### 8.1 `C++11`：用户提供（`user-provided`）与用户声明（`user-declared`）的区别

什么是用户提供的特殊成员函数，什么是用户声明的特殊成员函数？

-   如果我们只是使用`= default`来保留默认构造函数，这属于用户声明（`user-declared`）。
-   如果我们自己实现了函数体，那就是用户提供（`user-provided`）。

例如：

```cpp
struct UserProvided {
  UserProvided() {}
};

struct UserDeclared {
  UserDeclared() = default;
};
```

##### 8.2 指定初始化器（`Designated Initializers`）

既然我们已经回顾了聚合类型的概念，接下来谈谈`C++20`中一个有趣的变化。从某种程度上说，指定初始化器是为了解决`C`和`C++`在初始化语法上长期存在的差异，是对`C`语言兼容性的修正。

示例：

```cpp
struct Point {
  int y;
  int x;
  int z;
};

const Point p1{3, 0, 4};
```

在这个例子中，`Point`是聚合类型。我们可以使用花括号初始化，就像对`p1`所做的那样。现在想象一下，`Point`定义在一个头文件里，而你只看到`p1`的声明，你能判断哪些值对应哪个成员吗？更准确地说，`p1`中成员`y`的值是多少？对于那些认为是0的人，再仔细看代码。我故意把成员的声明顺序改成了`y, x, z`，而不是通常的`x, y, z`！为什么？因为我可以，这种情况在现实中确实会发生。我的意思是，仅仅看初始化的数值，是无法确定它们对应初始化哪个成员的。类的情况在技术上也是如此，但我们通常使用构造函数，可以固定成员的初始化顺序。

那么，我们该怎么办呢？制定编码规范是一个方法，但并不十分有效。例子里的`Point`只是无数未符合“自然假设”的情况之一，还有成百上千的类似情况存在。

###### 8.2.1 `C`语言中的指定初始化器（`Designated Initializers`）

对于所有用过`C`语言编程的人来说，你们知道解决方案。`C`语言有指定初始化器来初始化结构体。比如：

```cpp
struct Point {
  int y;
  int x;
  int z;
};

const Point p1 = {.y = 3, .x = 0, .z = 4};
```

这里 `.x = 0`就叫做指定初始化器。它让我们能够明确地指出想初始化哪个成员。对那些想说“这有什么新鲜”的人，我在`C++`代码中一直用这个特性。编译器以前作为扩展支持这个功能，但它不属于`C++`标准。几年前我做一个新`C++`项目时，经常用指定初始化器，结果遇到编译错误花了好长时间才明白，原来新项目的编译器（`Clang`）还没支持这个特性。后来我才知道，`GCC`的指定初始化器是作为编译器扩展实现的，并非标准`C++`。

###### 8.2.2 `C++20`中的指定初始化器

好消息是，`C++20`标准正式引入了指定初始化器。之前例子中的代码在`C++20`中可以无须任何扩展直接使用。对于熟悉`C`语言的朋友，`C++20`的指定初始化器有几点不同，主要因为`C++`对象有构造函数：

-   **全有或全无**：如果选择用指定初始化器初始化聚合体，所有初始化值都必须用指定初始化器语法。

-   **初始化顺序**：指定初始化器必须按照数据成员的声明顺序出现，编译器从左到右依次处理。

-   **唯一性**：指定初始化器必须唯一。`C`语言允许同一指定初始化器出现多次，但在`C++`中没有意义，而且会引起诸如构造函数调用次数的问题。

    ```cpp
    struct Point {
      int x;
      int y;
    };
    
    // C语言中允许重复指定相同成员（虽然意义不大）
    const Point p_c = {
      .x = 1,
      .x = 2,  // C语言允许，但后面会覆盖前面的值
      .y = 3
    };
    ```

-   **初始化形式**：`C++`允许用大括号初始化或等号初始化，而`C`只允许等号初始化。

-   **嵌套初始化**：当需要嵌套指定初始化器时，必须用等号初始化或大括号初始化。

请注意，无论是否使用指定初始化器，所有初始化器都被花括号`{}`包围，属于花括号初始化，这会禁止数值窄化转换。

**花括号初始化（`Braced Initialization`）**

花括号初始化有几个优点：

1.  **防止窄化转换（`narrowing conversions`）**
    在编译时会阻止精度丢失，比如防止把`double`赋值给`int`时丢失小数部分。

2.  **总是执行默认或零初始化**
    这意味着对象及其子对象要么调用默认构造函数，要么用零或等效值进行初始化。例如，指针的零值等效于`nullptr`。

3.  **避免最棘手的解析问题（`most vexing parse`）**

    ```cpp
    const Point p1();
    ```

    这被编译器识别为函数声明——声明一个无参、返回 `Point` 类型的函数`p1`，而不是对象的默认初始化。用括号无法表达默认或零初始化对象。

###### 8.2.1 `C++`代码中的不同初始化形式

我们复用`Point`，并新增一个包含`std::string`和`Point`的聚合体`NamedPoint`。

```cpp
// <A>: 类内成员初始化
struct Point {
  int y;
  int x = 2;
  int z;
};

struct NamedPoint {
  std::string name;
  Point pt;
};

// <B>: 初始化时不使用指定初始化器
const Point p0{3, 0, 4};

// <C>: 用指定初始化器初始化所有成员
// 等号和大括号两种初始化方式，可以混用
const Point p1{.y = 3, .x = 0, .z = 4};
const Point p2{.y{3}, .x{0}, .z = 4};

// <D>: 用指定初始化器初始化部分成员
const Point p3{.y = 3, .z = 4};

// <E>: 指定初始化器顺序与成员声明顺序不符，无法编译
const Point p4{.x = 0, .y = 3, .z = 4};

// <F>: 指定初始化器重复出现成员，无法编译
const Point p5{.y = 3, .y = 4}

// <G>: 嵌套指定初始化器
const NamedPoint p6{.name = "zero", .pt{.y{0}, .z{0}}};

// <H>: 外层聚合体使用指定初始化器
const NamedPoint p7{.name = "zero", .pt{0, 0, 0}};
```

-   在`A`中，成员`x`使用了类内成员初始化。需要注意的是，自`C++14`起，聚合体允许这种写法。

-   在`B`中，初始化`p0`没有使用指定初始化器，直接用花括号列表初始化聚合体。

-   在`C`中，针对 `p1`，使用了带等号的指定初始化器对`Point`的所有成员进行初始化。不过，同样也可以使用花括号初始化，如`p2`所示，两种初始化方式可以混合使用。

-   在`D`中，`p3`只用指定初始化器初始化了部分成员。这在聚合体成员提供默认值时特别有用。这里，`x`通过类内成员初始化默认值为2，而指定初始化器只初始化了`y`和`z`，省略了`x`。这是对早期标准的重大改进，也让聚合体的类内成员初始化更合理、更实用。

-   在`E`和`F`中，我们看到两个不能编译的示例。

    -   `E`的问题在于指定初始化器的顺序与`Point`中成员声明顺序不匹配。记住，这里我把成员顺序设为`y`在`x`之前，因此必须严格按照声明顺序使用指定初始化器，无法按个人习惯的顺序编写。

    -   `F`的问题是指定初始化器重复给同一个成员赋值，这段代码同样无法编译。对此，我个人认为这是合理的：重复初始化一个成员毫无意义，反而容易导致错误，比如想让`y`是3却写成了两次赋值。

-   在`G`中，我们看到了嵌套指定初始化器。外层使用`.name`作为指定初始化器，所以对成员`pt`也要使用指定初始化器形式，进而初始化`pt`的部分成员。

-   在`H`中，`pt`也可以不用指定初始化器，直接使用普通的花括号列表初始化。

###### 8.2.3 使用指定初始化器初始化聚合体的子集

新语言特性总是令人期待，但常常会有人问：这个特性到底有什么好处？我能用它做些什么？在上一节中，我们已经看到指定初始化器可以帮助我们结合类内成员初始化来初始化聚合体。现在，让我们更深入地看看这意味着什么。

我们继续使用之前例子中的`Point`聚合体，它为成员变量`x`使用了类内初始化。在之前的例子中，我们看到了`p3`，它只初始化了`y`和`z`，而`x`保持了类内初始化的默认值。你可能注意到了，`p3` 是一个`const`对象。

如果没有指定初始化器，要达到相同的效果，我们不得不这样写代码：

```cpp
Point p3{};
p3.y = 3;
p3.z = 4;
```

这里，我们必须先创建一个非`const`的`p3`，然后单独初始化所需的成员。这样做不仅丢失了对象的常量性，而且这个变量也无法作为静态变量直接在全局作用域定义。

当然，另一种方案是保持`const`，但需要在初始化时为所有成员都赋值（即使部分成员的值与类内默认值相同），比如：

```cpp
const Point p3{3, 0, 4};
```

如果我们为聚合体的所有成员都初始化，就能达到和指定初始化器一样的效果，如上所示，因此优势似乎只是细微的。

等等，你有没有注意到？我在这里把`x`初始化为`0`，但类内成员初始化为`2`！到底哪个是对的？当我们面对这样的代码时，很难一眼分辨。在这个例子里，我是故意写错的，代码虽然能编译通过，但值却不正确。

我的观点是，指定初始化器让我们只列出想初始化的成员，其他成员则自动采用默认值。这样一来，通过明确指定成员，类似错误可以被有效避免。

###### 8.2.4 使用指定初始化器初始化子集（无类内成员默认值）

接下来讨论一下默认值的问题。如果我没有给成员`x`提供类内默认初始化，也在指定初始化器里遗漏了它，会发生什么？比如下面这样：

```cpp
struct Point {
  int y;
  int x; // 没有类内默认初始化
  int z;
};
```

然后使用指定初始化器只初始化了部分成员：

```cpp
const Point p3{.y = 3, .z = 4};
```

那么`p3.x`的值是多少呢？答案是：由于使用的是花括号初始化（`braced initialization`），它会对所有未指定的成员执行默认初始化或零初始化。这里`x`是`int`类型，会被零初始化为`0`。即使用了指定初始化器，也不会有未初始化的成员。

当然，成员未初始化后值是否符合预期，则是另一回事。

**利用指定初始化器实现返回值优化**（`RVO`）

返回值优化（`Return Value Optimization`，简称`RVO`）是编译器早期的一种优化技术。

示例：

```cpp
struct NonCopyableOrMoveable {
  NonCopyableOrMoveable() = default;
  NonCopyableOrMoveable(const NonCopyableOrMoveable&) = delete;
  NonCopyableOrMoveable(NonCopyableOrMoveable&&) = delete;
  NonCopyableOrMoveable& operator=(const NonCopyableOrMoveable&) = delete;
  NonCopyableOrMoveable& operator=(NonCopyableOrMoveable&&) = delete;
  ~NonCopyableOrMoveable() = default;
};

NonCopyableOrMoveable RVO() {
  return {};
}

void Use() {
  auto myValue = RVO();
}
```

`NonCopyableOrMoveable`这个结构体既不支持拷贝，也不可移动。但上述代码依然能正常编译。因为编译器做了优化：它不会先在`RVO`函数内部创建返回对象再拷贝，而是直接在调用处为返回对象分配内存（也就是`myValue`），避免了不必要的拷贝或移动操作。自`C++17`起，这种优化是强制要求的。

利用指定初始化器，我们可以在返回语句中直接创建对象，享受`RVO`带来的性能优势：

```cpp
Point GetThePoint() {
	return {.y = 3, .z = 4};
}
```

类似的用法也可以用于向`std::vector`或其他`STL`容器中插入元素：

```cpp
auto GetVectorOfPoints() {
  std::vector<Point> points{};
  points.emplace_back(Point{.y = 5, .z = 6});
  return points;
}
```

`emplace_back`调用中直接用指定初始化器创建了只初始化部分成员的`Point`对象。通过显式命名成员和赋值，代码更加清晰，减少错误发生的可能性。

##### 8.2.5 `C++`中的命名参数：带指定初始化器的聚合体

我们之前提到使用指定初始化器创建`const`聚合体对象时，只需一句话即可初始化所有想要的成员。其实，这种方式还有更多优势。

举个例子，考虑一个函数`FileAccess`，它用来打开（写入或只读）文件，或者关闭文件：

```cpp
void FileAccess(bool open, bool close, bool readonly);

void Use() {
  FileAccess(true, false, true);
}
```

你能轻易看出每个布尔参数代表什么含义吗？代码审查时，这种写法常让人困惑。于是一些代码风格会要求在参数后面加注释：

```cpp
FileAccess(/*open*/ true, /*close*/ false, /*readonly*/ true);
```

然而注释会被编译器忽略，且随着时间推移可能变得不准确，维护这些注释是一件麻烦事。

**用聚合体和指定初始化器模拟命名参数**

如果我们用一个结构体`FileAccessParameters`把这些参数封装起来：

```cpp
struct FileAccessParameters {
  bool open;
  bool close;
  bool readonly;
};

void FileAccess(const FileAccessParameters& params);
```

调用时，我们可以用指定初始化器：

```cpp
FileAccess({.open = true, .close = false, .readonly = true});
```

代码变得清晰，无需注释，而且不容易出错。用聚合体加指定初始化器，可以看作是`C++`里“命名参数”的简易实现。

这种方式特别适合大量参数的函数，能灵活地只指定想设置的参数。相比默认参数必须从左到右赋值的限制，它更灵活。不过，我也建议用**强类型**替代大量`bool`参数，这样能进一步提升代码的健壮性。

###### 8.2.6 重载解析与指定初始化器

`C++`有一个`C`所没有的特性——**重载解析（overload resolution）**。当我们有一个接受聚合体参数的函数重载组，并且在调用时只使用花括号初始化且不显式指定类型时，就会遇到这个问题。

示例：

```cpp
struct Point2D {
  int X;   // 注意是大写的X
  int y;
};

void Add(const Point& p, int v);
void Add(const Point2D& p, int v);

void Use() {
  Add({.X = 3, .y = 4}, 3);   // 正常，调用Point2D版本
  Add({.y = 4, .x = 3}, 3);   // 正常，调用Point版本
  // Add({.y = 4}, 3);        // 错误，单独用.y会导致二义性，无法编译
}
```

这里，`Point`是之前定义过的含有成员`y`, `x`, `z`的聚合体；`Add`函数重载了两个版本，一个接受`Point`，另一个接受新的聚合体`Point2D`，后者使用了大写的`X`。

在调用时，如`Add({.X = 3, .y = 4}, 3);`和`Add({.y = 4, .x = 3}, 3);`，编译器可以通过成员名的大小写区分到底要调用哪个版本，成功完成重载解析。

然而，如果只写`Add({.y = 4}, 3);`，编译器会报错，因为`.y`是两个聚合体共有的成员，无法判定到底要初始化哪个类型，导致二义性。

这个现象的原因是：**在重载解析过程中，指定初始化器中成员的顺序并不影响类型推断**，所以即使你写成`.x = 3, .y = 4`，也不能帮助编译器确定类型；只有通过成员名称（比如大小写）区分的情况下，才能明确目标类型。

简而言之，**只有当初始化列表中的成员能唯一标识某个类型时，编译器才能正确选择对应的重载函数**。

##### 8.3 聚合体的直接初始化（`Direct-initialization for aggregates`）

`C++20`使初始化变得更统一了一些，尽管初始化相关的细节依然复杂得足以写成专门的书籍。自`C++11`起，除了传统的圆括号初始化，还引入了花括号初始化（`braced initialization`），这两种方式都有广泛应用。自此之后，关于用哪种初始化方式更好，哪个更优的讨论一直没有停歇。

有点遗憾的是，花括号初始化也被称为“统一初始化”（`uniform initialization`），当时的理想是给程序员提供一种能替代所有其他初始化方式且统一适用的语法，但事实证明这只是一个美好的愿望。

###### 8.3.1 初始化形式：花括号vs圆括号

花括号初始化的优点是能防止“窄化转换”（`narrowing conversion`），并且会执行默认或零初始化。但它也存在一些缺点。下面是一个经典例子：

```cpp
std::vector<int> v1(35);   // 使用圆括号
std::vector<int> v2{35};   // 使用花括号
```

第一个表达式创建了一个包含35个元素且全部初始化为0的`vector`；第二个表达式创建了一个包含1个元素，且元素值为35的`vector`。可以看出，这种差别对于程序流程来说虽然细微，但很容易引发误解。

这是因为花括号初始化也称作列表初始化（`list initialization`），它会调用接受`std::initializer_list`·的构造函数。`std::vector`是一个典型例子，导致了大量困惑，很难一眼看清楚发生了什么。

再看一个稍微复杂点的例子。假设我们要创建一个`Point`的`unique_ptr`，并且知道要用`std::make_unique`（这是推荐用法）。以下代码大家应该都写过很多次：

```cpp
auto pt = std::make_unique<Point>(4, 5);
```

问题不是它做了什么，而是它是否能编译通过？不要去找漏了分号什么的，语法没问题。但在`C++20`之前，编译器通常会报错，错误信息往往难以理解，让人一时想不起哪里写错了。

```bash
/usr/local/Cellar/llvm/20.1.6/bin/../include/c++/v1/__memory/unique_ptr.h:767:30: error: no matching constructor for initialization of 'Point'
  767 |   return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...));
      |                              ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~
test.cc:20:29: note: in instantiation of function template specialization 'std::make_unique<Point, int, int, 0>' requested here
   20 | int main() { auto pt = std::make_unique<Point>(4, 5); }
      |                             ^
test.cc:14:8: note: candidate constructor (the implicit copy constructor) not viable: requires 1 argument, but 2 were provided
   14 | struct Point {
      |        ^~~~~
test.cc:14:8: note: candidate constructor (the implicit move constructor) not viable: requires 1 argument, but 2 were provided
   14 | struct Point {
      |        ^~~~~
test.cc:14:8: note: candidate constructor (the implicit default constructor) not viable: requires 0 arguments, but 2 were provided
1 error generated.
```

这是因为`make_unique`内部是用圆括号初始化刚分配的`Point`对象，本质上相当于写了：

```cpp
const auto* pt = new Point(4, 5);
```

但根据`C++17`及更早标准，圆括号不能用来初始化聚合体对象，而`Point`是一个聚合体。缺少圆括号初始化聚合体的支持，导致无法轻松写出通用的完美转发函数。

**通用完美转发的一个折衷方案**

在`C++17`之前，如果想写一个通用的完美转发函数，可以用`std::is_constructible`配合`constexpr if`，然后在条件成立时用圆括号初始化，条件不成立时用花括号初始化。

但是这样会带来另一个问题：很难判断调用的是普通构造函数，还是接受`std::initializer_list`的构造函数。有时会导致错误的结论，比如有人认为必须给类型添加构造函数才能正常工作。其实这样做会导致类型不再是聚合体。

`C++20`的改进

`C++20`支持用圆括号列表初始化聚合体，让上面那段代码能够正常编译，效果类似花括号初始化。唯一不同的是圆括号初始化允许窄化转换。简单来说，圆括号初始化的语义没有变，只是现在可以用在更多场景。不过，`C++20`仍然存在一些比较复杂的语法解析问题，这些问题在下面代码清单中有所体现。

示例：

```cpp
struct Point {
  int y;
  int x;
  int z;
};

struct Nested {
  int i;
  Point pt;
};

struct LifeTimeExtension {
  int&& r; // 注意这是右值引用
};

// 聚合体初始化示例
Point bPt{2, 3, 5};
Point pPt(2, 3, 5); // C++20支持

// 数组初始化
int bArray[]{2, 3, 5};
int pArray[](2, 3, 5); // C++20支持

// 嵌套聚合体初始化
Nested bNested{
  9,
  {3, 4, 5}
};

// 嵌套的圆括号初始化是另一回事，不同语法
// Nested pNested(9, (3, 4, 5));

Point bDesignated{.y = 3};  	// 指定初始化器有效
// Point pDesignated(.y = 3); // 指定初始化器不支持圆括号

// 不允许窄化转换
// Point bNarrowing{3.5};
Point pNarrowing(3.5); // 允许窄化

Point bValueInit{}; 	// 默认或零初始化
Point pValueInit(); 	// 仍是函数声明

// 基础类型初始化
int bBuiltIn{4};
int pBuiltIn(4);

LifeTimeExtension bTemporary{4}; // OK
LifeTimeExtension pTemporary(4); // 悬挂引用，危险
```