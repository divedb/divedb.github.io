---
date: 2025-07-28
layout: post
title: go crc32
categories: goåŸºç¡€
tags: [goåŸºç¡€] 
---

#### ğŸ§© `CRC32`ç®€ä»‹

`CRC32`ï¼ˆå¾ªç¯å†—ä½™æ ¡éªŒï¼‰æ˜¯ä¸€ç§å¸¸ç”¨çš„é”™è¯¯æ£€æµ‹ç¼–ç ï¼Œå¹¿æ³›ç”¨äºç½‘ç»œé€šä¿¡ã€æ–‡ä»¶æ ¡éªŒç­‰é¢†åŸŸã€‚`Go`è¯­è¨€æ ‡å‡†åº“ä¸­çš„`hash/crc32`åŒ…æä¾›äº†`CRC32`ç®—æ³•çš„å®ç°ã€‚

#### ğŸ§© åŸºæœ¬ç”¨æ³•

##### ğŸŒ² è®¡ç®—å­—èŠ‚åˆ‡ç‰‡çš„`CRC32`

```go
package main

import (
	"fmt"
	"hash/crc32"
)

func main() {
	data := []byte("Hello, world!")
	checksum := crc32.ChecksumIEEE(data)
	fmt.Printf("CRC32: 0x%x\n", checksum)
}
```

##### ğŸŒ² è®¡ç®—æ–‡ä»¶çš„`CRC32`

```go
func fileCRC32(filename string) (uint32, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return 0, err
	}
	return crc32.ChecksumIEEE(data), nil
}
```

#### ğŸ§© é«˜çº§ç”¨æ³•

##### ğŸŒ² ä½¿ç”¨`Hash`æ¥å£

`crc32`åŒ…å®ç°äº†`hash.Hash`æ¥å£ï¼Œå¯ä»¥å¢é‡è®¡ç®—`CRC32`ï¼š

```go
func incrementalCRC32() {
	h := crc32.NewIEEE()
	h.Write([]byte("Hello, "))
	h.Write([]byte("world!"))
	fmt.Printf("CRC32: 0x%x\n", h.Sum32())
}
```

##### ğŸŒ² ä½¿ç”¨é¢„å®šä¹‰å¤šé¡¹å¼

`Go`æä¾›äº†å‡ ç§å¸¸è§çš„`CRC32`å¤šé¡¹å¼ï¼š

```go
const (
	// IEEE is by far and away the most common CRC-32 polynomial.
	// Used by ethernet (IEEE 802.3), v.42, fddi, gzip, zip, png, ...
	IEEE = 0xedb88320

	// Castagnoli's polynomial, used in iSCSI.
	// Has better error detection characteristics than IEEE.
	// https://dx.doi.org/10.1109/26.231911
	Castagnoli = 0x82f63b78

	// Koopman's polynomial.
	// Also has better error detection characteristics than IEEE.
	// https://dx.doi.org/10.1109/DSN.2002.1028931
	Koopman = 0xeb31d82e
)

func main() {
	table := crc32.MakeTable(crc32.Castagnoli)
	data := []byte("test data")
	fmt.Printf("Castagnoli CRC32: 0x%x\n", crc32.Checksum(data, table))
}
```

#### ğŸ§© æ€§èƒ½ä¼˜åŒ–

##### ğŸŒ² å¤ç”¨`Table`

åˆ›å»º`CRC32`è¡¨æœ‰ä¸€å®šå¼€é”€ï¼Œå¯ä»¥å¤ç”¨ï¼š

```go
var ieeeTable = crc32.MakeTable(crc32.IEEE)

func fastChecksum(data []byte) uint32 {
	return crc32.Checksum(data, ieeeTable)
}
```

##### ğŸŒ² å¹¶è¡Œè®¡ç®—

å¯¹äºå¤§æ–‡ä»¶å¯ä»¥åˆ†å—å¹¶è¡Œè®¡ç®—ï¼š

```go
func parallelFileCRC32(filename string) (uint32, error) {
	data, err := os.ReadFile(filename)
  
	if err != nil {
		return 0, err
	}

	const chunkSize = 64 * 1024 // 64KB
	chunks := len(data) / chunkSize

	var wg sync.WaitGroup
	results := make([]uint32, chunks)

	for i := 0; i < chunks; i++ {
		wg.Add(1)
		go func(i int) {
			start := i * chunkSize
			end := start + chunkSize
			if i == chunks-1 {
				end = len(data)
			}
			results[i] = crc32.ChecksumIEEE(data[start:end])
			wg.Done()
		}(i)
	}

	wg.Wait()

	// åˆå¹¶ç»“æœ
	final := uint32(0)
	for _, crc := range results {
		final = crc32.Update(final, ieeeTable, []byte{byte(crc >> 24), byte(crc >> 16), byte(crc >> 8), byte(crc)})
	}
  
	return final, nil
}
```

## 5. å®é™…åº”ç”¨ç¤ºä¾‹

### 5.1 ç½‘ç»œæ•°æ®æ ¡éªŒ

go

```
type Packet struct {
	Header  []byte
	Payload []byte
	CRC32   uint32
}

func (p *Packet) Verify() bool {
	h := crc32.NewIEEE()
	h.Write(p.Header)
	h.Write(p.Payload)
	return h.Sum32() == p.CRC32
}
```

### 5.2 æ–‡ä»¶å®Œæ•´æ€§æ£€æŸ¥

go

```
func checkFileIntegrity(originalFile, downloadedFile string) (bool, error) {
	origCRC, err := fileCRC32(originalFile)
	if err != nil {
		return false, err
	}

	dlCRC, err := fileCRC32(downloadedFile)
	if err != nil {
		return false, err
	}

	return origCRC == dlCRC, nil
}
```

## 6. æ³¨æ„äº‹é¡¹

1.  **å®‰å…¨æ€§**ï¼šCRC32ä¸æ˜¯åŠ å¯†å“ˆå¸Œï¼Œä¸åº”ç”¨äºå®‰å…¨æ•æ„Ÿåœºæ™¯
2.  **ç¢°æ’æ¦‚ç‡**ï¼šä¸åŒè¾“å…¥å¯èƒ½äº§ç”Ÿç›¸åŒCRC32å€¼
3.  **æ€§èƒ½**ï¼šå¯¹äºå¤§æ–‡ä»¶ï¼Œè€ƒè™‘ä½¿ç”¨æ›´å¿«çš„å“ˆå¸Œç®—æ³•å¦‚xxHash
4.  **å¤§å°ç«¯**ï¼šGoçš„å®ç°ä½¿ç”¨å°ç«¯å­—èŠ‚åº

## 7. ä¸å…¶ä»–è¯­è¨€æ¯”è¾ƒ

| ç‰¹æ€§       | Goå®ç°    | Pythonå®ç°     | Cå®ç°      |
| :--------- | :-------- | :------------- | :--------- |
| é»˜è®¤å¤šé¡¹å¼ | IEEE      | IEEE           | å–å†³äºå®ç° |
| æ¥å£ç±»å‹   | hash.Hash | zlib.crc32å‡½æ•° | å¤šç§åº“å®ç° |
| çº¿ç¨‹å®‰å…¨   | æ˜¯        | æ˜¯             | å–å†³äºå®ç° |

## 8. æ‰©å±•é˜…è¯»

1.  [Goå®˜æ–¹hash/crc32æ–‡æ¡£](https://pkg.go.dev/hash/crc32)
2.  [CRCç®—æ³•åŸç†](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)
3.  [æ›´å¿«çš„CRC32å®ç°](https://github.com/klauspost/crc32)