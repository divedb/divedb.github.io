---
date: 2025-07-29
layout: post
title: Linux命名空间
categories: Linux
tags: [Linux, 命名空间] 
---

`CLONE_NEWUTS`是`Linux`中`clone()`系统调用的一个标志，用于创建一个新的**UTS（UNIX Time-Sharing）命名空间**。`UTS`命名空间允许进程拥有独立的主机名（`hostname`）和域名（`domainname`），不会影响宿主机或其他命名空间的设置。

###### 🧠 一句话总结

>   `CLONE_NEWUTS` 让你可以给一个进程设置“自己的主机名”，它生活在一个“自己的小世界”里，改`hostname`不会影响系统其他部分。

#### 🔸 背景知识

在`Linux`中，`namespace`是容器技术的基础。它隔离了系统资源，比如进程、网络、挂载点等。`UTS namespace`是最基础的命名空间之一，主要用于隔离`hostname`和`domainname`。

#### 🔸 `CLONE_NEWUTS`作用

-   允许进程在新的`UTS`命名空间中运行。
-   改变主机名`sethostname()`只影响当前命名空间。
-   常用于容器技术（如`Docker`）中，让容器显示不同的主机名。

#### 🔸 系统调用关系图

```bash
clone(CLONE_NEWUTS, ...) ──► 创建新的 UTS 命名空间
                         └──► sethostname()仅影响该空间
```

#### 🔸 代码示例

这个例子展示如何创建一个带有独立主机名的子进程。

```c
#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

#define STACK_SIZE (1024 * 1024)

static int child_func(void *arg) {
  printf("==> [child] 当前主机名:\n");
  char hostname[100];
  gethostname(hostname, sizeof(hostname));
  printf("    %s\n", hostname);

  // 设置新的主机名
  const char *new_hostname = "child-uts";
  sethostname(new_hostname, strlen(new_hostname));
  printf("==> [child] 修改后的主机名:\n");
  gethostname(hostname, sizeof(hostname));
  printf("    %s\n", hostname);

  // 保持一段时间便于观察
  sleep(10);
  return 0;
}

int main() {
  char *stack = malloc(STACK_SIZE);
  if (!stack) {
    perror("malloc");
    exit(1);
  }

  printf("==> [parent] 当前主机名:\n");
  char hostname[100];
  gethostname(hostname, sizeof(hostname));
  printf("    %s\n", hostname);

  pid_t pid = clone(child_func, stack + STACK_SIZE, CLONE_NEWUTS | SIGCHLD, NULL);
  
  if (pid == -1) {
    perror("clone");
    exit(1);
  }

  waitpid(pid, NULL, 0);
  printf("==> [parent] 子进程结束，主机名仍为:\n");
  gethostname(hostname, sizeof(hostname));
  printf("    %s\n", hostname);

  free(stack);
  return 0;
}
```

#### 🔸 编译和运行方式（需`root`权限）

```bash
$ gcc -o uts_ns uts_ns.c
$ sudo ./uts_ns
```

#### 🔸 运行结果

```bash
==> [parent] 当前主机名:
    gc
==> [child] 当前主机名:
    gc
==> [child] 修改后的主机名:
    child-uts
==> [parent] 子进程结束，主机名仍为:
    gc
```

✅ **说明：** `child` 改变了自己的主机名，但不影响`parent`。这就是`CLONE_NEWUTS`的作用。

#### 📌 总结

| 项目     | 说明                          |
| -------- | ----------------------------- |
| 名称空间 | `UTS namespace`               |
| 标志     | `CLONE_NEWUTS`                |
| 能力     | 隔离主机名与域名              |
| 使用场景 | 容器（如`Docker`）、`sandbox` |
| 编程接口 | `clone()` + `sethostname()`   |
| 权限     | 需要`CAP_SYS_ADMIN`权限       |