---
date: 2025-07-29
layout: post
title: Linux命名空间【UTS】
categories: Linux
tags: [Linux, 命名空间] 
---

#### 🔸 背景知识

在`Linux`中，`namespace`是容器技术的基础。它隔离了系统资源，比如进程、网络、挂载点等。`UTS namespace`是最基础的命名空间之一，主要用于隔离`hostname`和`domainname`。

#### 🔸 `CLONE_NEWUTS`作用

-   允许进程在新的`UTS`命名空间中运行。
-   改变主机名`sethostname()`只影响当前命名空间。
-   常用于容器技术（如`Docker`）中，让容器显示不同的主机名。

#### 🔸 系统调用关系图

```bash
clone(CLONE_NEWUTS, ...) ──► 创建新的 UTS 命名空间
                         └──► sethostname()仅影响该空间
```

#### 🔸 代码示例

这个例子展示如何创建一个带有独立主机名的子进程。

```c
#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

#define STACK_SIZE (1024 * 1024)

static int child_func(void *arg) {
  printf("==> [child] 当前主机名:\n");
  char hostname[100];
  gethostname(hostname, sizeof(hostname));
  printf("    %s\n", hostname);

  // 设置新的主机名
  const char *new_hostname = "child-uts";
  sethostname(new_hostname, strlen(new_hostname));
  printf("==> [child] 修改后的主机名:\n");
  gethostname(hostname, sizeof(hostname));
  printf("    %s\n", hostname);

  // 保持一段时间便于观察
  sleep(10);
  return 0;
}

int main() {
  char *stack = malloc(STACK_SIZE);
  if (!stack) {
    perror("malloc");
    exit(1);
  }

  printf("==> [parent] 当前主机名:\n");
  char hostname[100];
  gethostname(hostname, sizeof(hostname));
  printf("    %s\n", hostname);

  pid_t pid = clone(child_func, stack + STACK_SIZE, CLONE_NEWUTS | SIGCHLD, NULL);
  
  if (pid == -1) {
    perror("clone");
    exit(1);
  }

  waitpid(pid, NULL, 0);
  printf("==> [parent] 子进程结束，主机名仍为:\n");
  gethostname(hostname, sizeof(hostname));
  printf("    %s\n", hostname);

  free(stack);
  return 0;
}
```

#### 🔸 编译和运行方式（需`root`权限）

```bash
$ gcc -o uts_ns uts_ns.c
$ sudo ./uts_ns
```

#### 🔸 运行结果

```bash
==> [parent] 当前主机名:
    gc
==> [child] 当前主机名:
    gc
==> [child] 修改后的主机名:
    child-uts
==> [parent] 子进程结束，主机名仍为:
    gc
```

✅ **说明：** `child` 改变了自己的主机名，但不影响`parent`。这就是`CLONE_NEWUTS`的作用。

#### 📌 总结

| 项目     | 说明                          |
| -------- | ----------------------------- |
| 名称空间 | `UTS namespace`               |
| 标志     | `CLONE_NEWUTS`                |
| 能力     | 隔离主机名与域名              |
| 使用场景 | 容器（如`Docker`）、`sandbox` |
| 编程接口 | `clone()` + `sethostname()`   |
| 权限     | 需要`CAP_SYS_ADMIN`权限       |

<hr/>

#### 🔹 使用`lsns`命令查看所有`UTS`命名空间

```bash
$ lsns -t uts
```

输出会列出所有当前系统中的`UTS`命名空间，例如：

```bash
        NS TYPE NPROCS   PID USER COMMAND
4026531838 uts      76  1101 gc   /lib/systemd/systemd --user
```

其中：

-   `NS`是`namespace`的`inode`号；
-   `NPROCS`是使用该`namespace`的进程数量；
-   `PID`是最早进入该`namespace`的进程；
-   `COMMAND`是启动该进程的命令。

#### 🔹 查看某个进程的`UTS`命名空间

```bash
$ ls -l /proc/<pid>/ns/uts
```

例如：

```bash
$ ls -l /proc/1234/ns/uts
```

输出：

```bash
$ lrwxrwxrwx 1 root root 0 Jul 30 09:00 /proc/1234/ns/uts -> 'uts:[4026532249]'
```

#### 🔹 对比两个进程的`UTS`命名空间是否相同

```bash
$ readlink /proc/1234/ns/uts
$ readlink /proc/5678/ns/uts
```

如果两个输出结果一样，则它们在同一个`UTS`命名空间中；否则为不同命名空间。

#### 🔹 查看`hostname`是否被隔离

在不同`UTS`命名空间中，可以设置独立的`hostname`和`domainname`：

```bash
$ hostname
$ domainname
```

如果你进入了某个容器或`namespace`后，这两个值不同于宿主机，那说明当前`shell`已处于不同的`UTS`命名空间中。