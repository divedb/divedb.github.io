---
date: 2025-07-31
layout: post
title: 内存管理
categories: Linux
tags: [Linux, 内存] 
---

内存管理的实现涵盖了许多领域：

-   内存中的物理内存页的管理；

-   分配大块内存的伙伴系统；

-   分配较小块内存的`slab`、`slub`和`slob`分配器；

-   分配非连续内存块的`vmalloc`机制；

-   进程的地址空间。

实际上内核会区分3 种配置选项：`FLATMEM`、`DISCONTIGMEM`和`SPARSEMEM`。`SPARSEMEM`和`DISCONTIGMEM`实际上作用相同，但从开发者的角度看来，对应代码的质量有所不同。`SPARSEMEM`被认为更多是试验性的，不那么稳定，但有一些性能优化。我们认为`DISCONTIGMEM`相关代码更稳定一些，但不具备内存热插拔之类的新特性。

✅ `Linux`内核是否使用`bitmap`表示整个物理内存？

是，但不是直接拿`bitmap`代表整个物理内存分配状态。在`Linux`的内存管理中，`bitmap`用于一些子系统，比如：

-   `buddy allocator`：使用`bitmap`来跟踪每阶每页块是否空闲
-   `page allocator`：每个页的元数据由`struct page`表示，整个物理页数组`mem_map[]`是主控
-   `SLAB/SLUB/SLOB allocators`：也使用`bitmap`管理小块分配（<1页）

✅ 物理内存划分成阶级（`order`）管理是否基于`bitmap`？

是的，`buddy system`在每个`zone`的每个`order`中都有一个`freelist`和`bitmap`。

-   `Linux`内核将物理内存分为不同的`zone`（`DMA, Normal, HighMem...`）
-   每个`zone`维护一个`free_area[]`数组，每个元素表示一个阶

```c
/* file: include/linux/mmzone.h */
struct zone {
  /* zone_start_pfn == zone_start_paddr >> PAGE_SHIFT */
	unsigned long		zone_start_pfn;

	/*
	 * spanned_pages is the total pages spanned by the zone, including
	 * holes, which is calculated as:
	 * 	spanned_pages = zone_end_pfn - zone_start_pfn;
	 *
	 * present_pages is physical pages existing within the zone, which
	 * is calculated as:
	 *	present_pages = spanned_pages - absent_pages(pages in holes);
	 *
	 * present_early_pages is present pages existing within the zone
	 * located on memory available since early boot, excluding hotplugged
	 * memory.
	 *
	 * managed_pages is present pages managed by the buddy system, which
	 * is calculated as (reserved_pages includes pages allocated by the
	 * bootmem allocator):
	 *	managed_pages = present_pages - reserved_pages;
	 *
	 * cma pages is present pages that are assigned for CMA use
	 * (MIGRATE_CMA).
	 *
	 * So present_pages may be used by memory hotplug or memory power
	 * management logic to figure out unmanaged pages by checking
	 * (present_pages - managed_pages). And managed_pages should be used
	 * by page allocator and vm scanner to calculate all kinds of watermarks
	 * and thresholds.
	 *
	 * Locking rules:
	 *
	 * zone_start_pfn and spanned_pages are protected by span_seqlock.
	 * It is a seqlock because it has to be read outside of zone->lock,
	 * and it is done in the main allocator path.  But, it is written
	 * quite infrequently.
	 *
	 * The span_seq lock is declared along with zone->lock because it is
	 * frequently read in proximity to zone->lock.  It's good to
	 * give them a chance of being in the same cacheline.
	 *
	 * Write access to present_pages at runtime should be protected by
	 * mem_hotplug_begin/done(). Any reader who can't tolerant drift of
	 * present_pages should use get_online_mems() to get a stable value.
	 */
	atomic_long_t		managed_pages;
	unsigned long		spanned_pages;
	unsigned long		present_pages;
	struct free_area free_area[MAX_ORDER]; // MAX_ORDER=11，阶0~10
};
```

-   每个 `free_area` 长这样：

```
c


复制编辑
struct free_area {
    struct list_head free_list; // 双向链表，记录空闲块
    unsigned long *map;         // bitmap，记录每个块是否空闲
};
```

### bitmap 的作用：

-   标记某个阶级的页块是否空闲
-   和 freelist 一起支持快速合并/拆分

------

## ✅ 3. 内存是如何分阶管理的？

以 1GB 内存为例（不考虑 NUMA 和 zone）：

-   拆分成 4KB 页（2^20 / 2^12 = 2^8 = 256K 页）
-   每个 `struct page` 代表一个物理页，在 boot 时初始化 `mem_map[]`
-   每个 zone 建立阶级数组 `free_area[0...MAX_ORDER-1]`
-   每阶下有若干个 block，每 block 是 2^order 页
-   每阶有对应的 bitmap 和 free_list

`/proc/zoneinfo` 是 Linux 内核提供的一个文件，用于显示系统内存区域(zone)的详细信息。这些信息对于理解系统内存使用情况和性能调优非常有帮助。

## 主要部分解析

### 1. 节点和区域结构

输出按 NUMA 节点(Node)和内存区域(zone)组织：

text

```
Node 0, zone      DMA
Node 0, zone    DMA32
Node 0, zone   Normal
Node 0, zone  Movable
Node 0, zone   Device
```

-   **Node 0**：表示第一个 NUMA 节点(在单处理器系统中通常只有 Node 0)
-   **zone**：内存区域类型，常见的有：
    -   **DMA**：直接内存访问区域(通常 <16MB)
    -   **DMA32**：32位设备可访问区域(通常 <4GB)
    -   **Normal**：普通内存区域
    -   **Movable**：可移动内存区域(用于内存热插拔)
    -   **Device**：设备内存区域

### 2. 关键字段解释

每个区域包含以下重要信息：

#### 内存统计

-   **pages free**：空闲页面数
-   **min/low/high**：内存水位标记，用于内存回收
    -   `min`：最低水位，低于此值开始积极回收内存
    -   `low`：低水位，低于此值开始温和回收
    -   `high`：高水位，回收内存到此值停止
-   **spanned/present/managed**：
    -   `spanned`：区域总大小(包括空洞)
    -   `present`：实际存在的物理内存
    -   `managed`：由伙伴系统管理的内存

#### 使用情况统计

-   **nr_*** 系列：各种类型页面的计数
    -   `nr_inactive_anon`：非活跃的匿名页
    -   `nr_active_anon`：活跃的匿名页(进程堆栈、堆等)
    -   `nr_inactive_file`：非活跃的文件缓存页
    -   `nr_active_file`：活跃的文件缓存页
    -   `nr_slab_reclaimable`：可回收的slab内存
    -   `nr_slab_unreclaimable`：不可回收的slab内存
    -   `nr_mapped`：被映射到进程地址空间的页面

#### NUMA相关统计

-   **numa_hit**：在本节点分配成功次数
-   **numa_miss**：在本节点分配失败次数
-   **numa_local**：本地分配次数

#### 每CPU页缓存(pagesets)

显示每个CPU核心的页缓存状态：

-   `count`：当前缓存页面数
-   `high`：高水位标记
-   `batch`：批量操作大小

### 3. 具体区域分析

#### DMA 区域

-   非常小的内存区域(仅4095页，约16MB)
-   主要用于旧设备DMA操作
-   当前空闲页面很少(3576页，约14MB)

#### DMA32 区域

-   中等大小区域(约3GB物理内存)
-   空闲内存较多(426926页，约1.7GB)
-   文件缓存较少，匿名页较多

#### Normal 区域

-   主要内存区域(约5GB物理内存)
-   空闲内存较少(13307页，约52MB)
-   文件缓存和匿名页都很多
-   有133页等待写入磁盘(nr_zone_write_pending)

### 4. 系统整体内存状况

从输出可以看出：

1.  系统主要使用Normal区域内存，且空闲内存较少(仅52MB)
2.  DMA32区域还有较多空闲内存(1.7GB)
3.  文件缓存占用较多内存(约732902页，2.8GB)
4.  匿名页也占用较多内存(约650843页，2.5GB)
5.  有144页脏数据等待写入(nr_dirty)
6.  系统没有使用交换空间(nr_swapcached=0)

### 5. 性能调优提示

-   系统Normal区域内存压力较大(空闲内存接近low水位)
-   如果应用性能下降，可能需要：
    -   减少内存使用
    -   增加swap空间
    -   调整vm.swappiness参数
    -   优化应用使用文件缓存的方式

这个输出对于诊断内存相关性能问题非常有用，特别是在内存不足或交换频繁的情况下。