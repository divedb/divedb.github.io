---
date: 2025-07-31
layout: post
title: å†…å­˜ç®¡ç†
categories: Linux
tags: [Linux, å†…å­˜] 
---

å†…å­˜ç®¡ç†çš„å®ç°æ¶µç›–äº†è®¸å¤šé¢†åŸŸï¼š

-   å†…å­˜ä¸­çš„ç‰©ç†å†…å­˜é¡µçš„ç®¡ç†ï¼›

-   åˆ†é…å¤§å—å†…å­˜çš„ä¼™ä¼´ç³»ç»Ÿï¼›

-   åˆ†é…è¾ƒå°å—å†…å­˜çš„`slab`ã€`slub`å’Œ`slob`åˆ†é…å™¨ï¼›

-   åˆ†é…éè¿ç»­å†…å­˜å—çš„`vmalloc`æœºåˆ¶ï¼›

-   è¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚

å®é™…ä¸Šå†…æ ¸ä¼šåŒºåˆ†3 ç§é…ç½®é€‰é¡¹ï¼š`FLATMEM`ã€`DISCONTIGMEM`å’Œ`SPARSEMEM`ã€‚`SPARSEMEM`å’Œ`DISCONTIGMEM`å®é™…ä¸Šä½œç”¨ç›¸åŒï¼Œä½†ä»å¼€å‘è€…çš„è§’åº¦çœ‹æ¥ï¼Œå¯¹åº”ä»£ç çš„è´¨é‡æœ‰æ‰€ä¸åŒã€‚`SPARSEMEM`è¢«è®¤ä¸ºæ›´å¤šæ˜¯è¯•éªŒæ€§çš„ï¼Œä¸é‚£ä¹ˆç¨³å®šï¼Œä½†æœ‰ä¸€äº›æ€§èƒ½ä¼˜åŒ–ã€‚æˆ‘ä»¬è®¤ä¸º`DISCONTIGMEM`ç›¸å…³ä»£ç æ›´ç¨³å®šä¸€äº›ï¼Œä½†ä¸å…·å¤‡å†…å­˜çƒ­æ’æ‹”ä¹‹ç±»çš„æ–°ç‰¹æ€§ã€‚

###### ğŸƒ 3.2.1 æ¦‚è¿°

â€‹	é¦–å…ˆï¼Œå†…å­˜åˆ’åˆ†ä¸ºç»“ç‚¹ã€‚æ¯ä¸ªç»“ç‚¹å…³è”åˆ°ç³»ç»Ÿä¸­çš„ä¸€ä¸ªå¤„ç†å™¨ï¼Œåœ¨å†…æ ¸ä¸­è¡¨ç¤ºä¸º`pg_data_t`çš„å®ä¾‹ã€‚å„ä¸ªç»“ç‚¹åˆåˆ’åˆ†ä¸ºå†…å­˜åŸŸï¼Œæ˜¯å†…å­˜çš„è¿›ä¸€æ­¥ç»†åˆ†ã€‚ä¾‹å¦‚ï¼Œå¯¹å¯ç”¨äºï¼ˆ`ISA`è®¾å¤‡çš„ï¼‰`DMA`æ“ä½œçš„å†…å­˜åŒºæ˜¯æœ‰é™åˆ¶çš„ã€‚åªæœ‰å‰`16 MiB`é€‚ç”¨ï¼Œè¿˜æœ‰ä¸€ä¸ªé«˜ç«¯å†…å­˜åŒºåŸŸæ— æ³•ç›´æ¥æ˜ å°„ã€‚åœ¨äºŒè€…ä¹‹é—´æ˜¯é€šç”¨çš„â€œæ™®é€šâ€å†…å­˜åŒºã€‚å› æ­¤ä¸€ä¸ªç»“ç‚¹æœ€å¤šç”±3ä¸ªå†…å­˜åŸŸç»„æˆã€‚å†…æ ¸å¼•å…¥äº†ä¸‹åˆ—å¸¸é‡æ¥åŒºåˆ†å®ƒä»¬ã€‚

```c
/* file: linux/mmzone.h */
enum zone_type {
	/*
	 * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able
	 * to DMA to all of the addressable memory (ZONE_NORMAL).
	 * On architectures where this area covers the whole 32 bit address
	 * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller
	 * DMA addressing constraints. This distinction is important as a 32bit
	 * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit
	 * platforms may need both zones as they support peripherals with
	 * different DMA addressing limitations.
	 */
#ifdef CONFIG_ZONE_DMA
	ZONE_DMA,
#endif
#ifdef CONFIG_ZONE_DMA32
	ZONE_DMA32,
#endif
	/*
	 * Normal addressable memory is in ZONE_NORMAL. DMA operations can be
	 * performed on pages in ZONE_NORMAL if the DMA devices support
	 * transfers to all addressable memory.
	 */
	ZONE_NORMAL,
#ifdef CONFIG_HIGHMEM
	/*
	 * A memory area that is only addressable by the kernel through
	 * mapping portions into its own address space. This is for example
	 * used by i386 to allow the kernel to address the memory beyond
	 * 900MB. The kernel will set up special mappings (page
	 * table entries on i386) for each page that the kernel needs to
	 * access.
	 */
	ZONE_HIGHMEM,
#endif
	/*
	 * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains
	 * movable pages with few exceptional cases described below. Main use
	 * cases for ZONE_MOVABLE are to make memory offlining/unplug more
	 * likely to succeed, and to locally limit unmovable allocations - e.g.,
	 * to increase the number of THP/huge pages. Notable special cases are:
	 *
	 * 1. Pinned pages: (long-term) pinning of movable pages might
	 *    essentially turn such pages unmovable. Therefore, we do not allow
	 *    pinning long-term pages in ZONE_MOVABLE. When pages are pinned and
	 *    faulted, they come from the right zone right away. However, it is
	 *    still possible that address space already has pages in
	 *    ZONE_MOVABLE at the time when pages are pinned (i.e. user has
	 *    touches that memory before pinning). In such case we migrate them
	 *    to a different zone. When migration fails - pinning fails.
	 * 2. memblock allocations: kernelcore/movablecore setups might create
	 *    situations where ZONE_MOVABLE contains unmovable allocations
	 *    after boot. Memory offlining and allocations fail early.
	 * 3. Memory holes: kernelcore/movablecore setups might create very rare
	 *    situations where ZONE_MOVABLE contains memory holes after boot,
	 *    for example, if we have sections that are only partially
	 *    populated. Memory offlining and allocations fail early.
	 * 4. PG_hwpoison pages: while poisoned pages can be skipped during
	 *    memory offlining, such pages cannot be allocated.
	 * 5. Unmovable PG_offline pages: in paravirtualized environments,
	 *    hotplugged memory blocks might only partially be managed by the
	 *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The
	 *    parts not manged by the buddy are unmovable PG_offline pages. In
	 *    some cases (virtio-mem), such pages can be skipped during
	 *    memory offlining, however, cannot be moved/allocated. These
	 *    techniques might use alloc_contig_range() to hide previously
	 *    exposed pages from the buddy again (e.g., to implement some sort
	 *    of memory unplug in virtio-mem).
	 * 6. ZERO_PAGE(0), kernelcore/movablecore setups might create
	 *    situations where ZERO_PAGE(0) which is allocated differently
	 *    on different platforms may end up in a movable zone. ZERO_PAGE(0)
	 *    cannot be migrated.
	 * 7. Memory-hotplug: when using memmap_on_memory and onlining the
	 *    memory to the MOVABLE zone, the vmemmap pages are also placed in
	 *    such zone. Such pages cannot be really moved around as they are
	 *    self-stored in the range, but they are treated as movable when
	 *    the range they describe is about to be offlined.
	 *
	 * In general, no unmovable allocations that degrade memory offlining
	 * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())
	 * have to expect that migrating pages in ZONE_MOVABLE can fail (even
	 * if has_unmovable_pages() states that there are no unmovable pages,
	 * there can be false negatives).
	 */
	ZONE_MOVABLE,
#ifdef CONFIG_ZONE_DEVICE
	ZONE_DEVICE,
#endif
	__MAX_NR_ZONES

};
```

-   `ZONE_DMA`æ ‡è®°é€‚åˆ`DMA`çš„å†…å­˜åŸŸã€‚è¯¥åŒºåŸŸçš„é•¿åº¦ä¾èµ–äºå¤„ç†å™¨ç±»å‹ã€‚åœ¨`IA-32`è®¡ç®—æœºä¸Šï¼Œä¸€èˆ¬çš„é™åˆ¶æ˜¯`16 MiB`ï¼Œè¿™æ˜¯ç”±å¤è€çš„`ISA`è®¾å¤‡å¼ºåŠ çš„è¾¹ç•Œã€‚ä½†æ›´ç°ä»£çš„è®¡ç®—æœºä¹Ÿå¯èƒ½å—è¿™ä¸€é™åˆ¶çš„å½±å“ã€‚

-   `ZONE_DMA32`æ ‡è®°äº†ä½¿ç”¨32ä½åœ°å€å­—å¯å¯»å€ã€é€‚åˆ`DMA`çš„å†…å­˜åŸŸã€‚æ˜¾ç„¶ï¼Œåªæœ‰åœ¨64ä½ç³»ç»Ÿä¸Šï¼Œä¸¤ç§`DMA`å†…å­˜åŸŸæ‰æœ‰å·®åˆ«ã€‚åœ¨32ä½è®¡ç®—æœºä¸Šï¼Œæœ¬å†…å­˜åŸŸæ˜¯ç©ºçš„ï¼Œå³é•¿åº¦ä¸º`0 MiB`ã€‚åœ¨`Alpha`å’Œ`AMD64`ç³»ç»Ÿä¸Šï¼Œè¯¥å†…å­˜åŸŸçš„é•¿åº¦å¯èƒ½ä»0åˆ°`4 GiB`ã€‚

-   `ZONE_NORMAL`æ ‡è®°äº†å¯ç›´æ¥æ˜ å°„åˆ°å†…æ ¸æ®µçš„æ™®é€šå†…å­˜åŸŸã€‚è¿™æ˜¯åœ¨æ‰€æœ‰ä½“ç³»ç»“æ„ä¸Šä¿è¯éƒ½ä¼šå­˜åœ¨çš„å”¯ä¸€å†…å­˜åŸŸï¼Œä½†æ— æ³•ä¿è¯è¯¥åœ°å€èŒƒå›´å¯¹åº”äº†å®é™…çš„ç‰©ç†å†…å­˜ã€‚ä¾‹å¦‚ï¼Œå¦‚æœ`AMD64`ç³»ç»Ÿæœ‰`2 GiB`å†…å­˜ï¼Œé‚£ä¹ˆæ‰€æœ‰å†…å­˜éƒ½å±äº`ZONE_DMA32`èŒƒå›´ï¼Œè€Œ`ZONE_NORMAL`åˆ™ä¸ºç©ºã€‚

-   `ZONE_HIGHMEM`æ ‡è®°äº†è¶…å‡ºå†…æ ¸æ®µçš„ç‰©ç†å†…å­˜ã€‚

>æ ¹æ®ç¼–è¯‘æ—¶çš„é…ç½®ï¼Œå¯èƒ½æ— éœ€è€ƒè™‘æŸäº›å†…å­˜åŸŸã€‚ä¾‹å¦‚åœ¨64ä½ç³»ç»Ÿä¸­ï¼Œå¹¶ä¸éœ€è¦é«˜ç«¯å†…å­˜åŸŸã€‚å¦‚æœæ”¯æŒäº†åªèƒ½è®¿é—®`4 GiB`ä»¥ä¸‹å†…å­˜çš„32ä½å¤–è®¾ï¼Œæ‰éœ€è¦`DMA32`å†…å­˜åŸŸã€‚

###### ğŸƒ 3.2.2 æ•°æ®ç»“æ„

æˆ‘å·²ç»è§£é‡Šäº†ç”¨äºå†…å­˜ç®¡ç†çš„å„ç§æ•°æ®ç»“æ„ä¹‹é—´çš„å…³ç³»ï¼Œç°åœ¨æˆ‘ä»¬åˆ†åˆ«è®²è§£å„ä¸ªæ•°æ®ç»“æ„ã€‚

1.   ç»“ç‚¹ç®¡ç†

pg_data_tæ˜¯ç”¨äºè¡¨ç¤ºç»“ç‚¹çš„åŸºæœ¬å…ƒç´ ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š

```c
typedef structure pglist_data {
  struct zone node_zones[MAX_NR_ZONES];
  struct zonelist node_zonelists[MAX_ZONELISTS];
  int nr_zones;
  struct page *node_mem_map;
  unsigned long node_start_pfn;
	unsigned long node_present_pages; /* ç‰©ç†å†…å­˜é¡µçš„æ€»æ•° */
	unsigned long node_spanned_pages; /* ç‰©ç†å†…å­˜é¡µçš„æ€»é•¿åº¦ï¼ŒåŒ…å«æ´åœ¨å†… */
  int node_id;
  wait_queue_head_t kswapd_wait;
	struct task_struct *kswapd;
} pg_data_t;
```

-   `node_zones`æ˜¯ä¸€ä¸ªæ•°ç»„ï¼ŒåŒ…å«äº†ç»“ç‚¹ä¸­å„å†…å­˜åŸŸçš„æ•°æ®ç»“æ„ã€‚

-   `node_zonelists`æŒ‡å®šäº†å¤‡ç”¨ç»“ç‚¹åŠå…¶å†…å­˜åŸŸçš„åˆ—è¡¨ï¼Œä»¥ä¾¿åœ¨å½“å‰ç»“ç‚¹æ²¡æœ‰å¯ç”¨ç©ºé—´æ—¶ï¼Œåœ¨å¤‡ç”¨ç»“ç‚¹åˆ†é…å†…å­˜ã€‚

-   ç»“ç‚¹ä¸­ä¸åŒå†…å­˜åŸŸçš„æ•°ç›®ä¿å­˜åœ¨`nr_zones`ã€‚

-   `node_mem_map`æ˜¯æŒ‡å‘`page`å®ä¾‹æ•°ç»„çš„æŒ‡é’ˆï¼Œç”¨äºæè¿°ç»“ç‚¹çš„æ‰€æœ‰ç‰©ç†å†…å­˜é¡µã€‚å®ƒåŒ…å«äº†ç»“ç‚¹ä¸­æ‰€æœ‰å†…å­˜åŸŸçš„é¡µã€‚

-   `node_start_pfn`æ˜¯è¯¥`NUMA`ç»“ç‚¹ç¬¬ä¸€ä¸ªé¡µå¸§çš„é€»è¾‘ç¼–å·ã€‚ç³»ç»Ÿä¸­æ‰€æœ‰ç»“ç‚¹çš„é¡µå¸§æ˜¯ä¾æ¬¡ç¼–å·çš„ï¼Œæ¯ä¸ªé¡µå¸§çš„å·ç éƒ½æ˜¯å…¨å±€å”¯ä¸€çš„ï¼ˆä¸åªæ˜¯ç»“ç‚¹å†…å”¯ä¸€ï¼‰ã€‚

-   `node_start_pfn`åœ¨`UMA`ç³»ç»Ÿä¸­æ€»æ˜¯0ï¼Œå› ä¸ºå…¶ä¸­åªæœ‰ä¸€ä¸ªç»“ç‚¹ï¼Œå› æ­¤å…¶ç¬¬ä¸€ä¸ªé¡µå¸§ç¼–å·æ€»æ˜¯0ã€‚

-   `node_present_pages`æŒ‡å®šäº†ç»“ç‚¹ä¸­é¡µå¸§çš„æ•°ç›®ï¼Œè€Œ`node_spanned_pages`åˆ™ç»™å‡ºäº†è¯¥ç»“ç‚¹ä»¥é¡µå¸§ä¸ºå•ä½è®¡ç®—çš„é•¿åº¦ã€‚äºŒè€…çš„å€¼ä¸ä¸€å®šç›¸åŒï¼Œå› ä¸ºç»“ç‚¹ä¸­å¯èƒ½æœ‰ä¸€äº›ç©ºæ´ï¼Œå¹¶ä¸å¯¹åº”çœŸæ­£çš„é¡µå¸§ã€‚

-   `node_id`æ˜¯å…¨å±€ç»“ç‚¹`ID`ã€‚ç³»ç»Ÿä¸­çš„`NUMA`ç»“ç‚¹éƒ½ä»0å¼€å§‹ç¼–å·ã€‚
-   `kswapd_wait`æ˜¯äº¤æ¢å®ˆæŠ¤è¿›ç¨‹ï¼ˆ`swap daemon`ï¼‰çš„ç­‰å¾…é˜Ÿåˆ—ï¼Œåœ¨å°†é¡µå¸§æ¢å‡ºç»“ç‚¹æ—¶ä¼šç”¨åˆ°ï¼ˆç¬¬18ç« ä¼šè¯¦ç»†è®¨è®ºè¯¥è¿‡ç¨‹ï¼‰ ã€‚`kswapd`æŒ‡å‘è´Ÿè´£è¯¥ç»“ç‚¹çš„äº¤æ¢å®ˆæŠ¤è¿›ç¨‹çš„`task_struct`ã€‚

ç»“ç‚¹çŠ¶æ€ç®¡ç†

å¦‚æœç³»ç»Ÿä¸­ç»“ç‚¹å¤šäºä¸€ä¸ªï¼Œå†…æ ¸ä¼šç»´æŠ¤ä¸€ä¸ªä½å›¾ï¼Œç”¨ä»¥æä¾›å„ä¸ªç»“ç‚¹çš„çŠ¶æ€ä¿¡æ¯ã€‚çŠ¶æ€æ˜¯ç”¨ä½æ©ç æŒ‡å®šçš„ï¼Œå¯ä½¿ç”¨ä¸‹åˆ—å€¼ï¼š

```c
/* include/linux/nodemask.h */

/*
 * Bitmasks that are kept for all the nodes.
 */
enum node_states {
	N_POSSIBLE,						/* The node could become online at some point */
	N_ONLINE,							/* The node is online */
	N_NORMAL_MEMORY,			/* The node has regular memory */
#ifdef CONFIG_HIGHMEM
	N_HIGH_MEMORY,				/* The node has regular or high memory */
#else
	N_HIGH_MEMORY = N_NORMAL_MEMORY,
#endif
	N_MEMORY,							/* The node has memory(regular, high, movable) */
	N_CPU,								/* The node has one or more cpus */
	N_GENERIC_INITIATOR,	/* The node has one or more Generic Initiators */
	NR_NODE_STATES
};
```

çŠ¶æ€`N_POSSIBLE`ã€`N_ONLINE`å’Œ`N_CPU`ç”¨äº`CPU`å’Œå†…å­˜çš„çƒ­æ’æ‹”ã€‚å¯¹å†…å­˜ç®¡ç†æœ‰å¿…è¦çš„æ ‡å¿—æ˜¯`N_HIGH_MEMORY`å’Œ`N_NORMAL_MEMORY`ã€‚å¦‚æœç»“ç‚¹æœ‰æ™®é€šæˆ–é«˜ç«¯å†…å­˜åˆ™ä½¿ç”¨`N_HIGH_MEMORY`ï¼Œä»…å½“ç»“ç‚¹æ²¡æœ‰é«˜ç«¯å†…å­˜æ‰è®¾ç½®`N_NORMAL_MEMORY`ã€‚

2.   å†…å­˜åŸŸ

å†…æ ¸ä½¿ç”¨`zone`ç»“æ„æ¥æè¿°å†…å­˜åŸŸã€‚å…¶å®šä¹‰å¦‚ä¸‹ï¼š

```c
struct zone {
  /* Read-mostly fields */

	/* zone watermarks, access with *_wmark_pages(zone) macros */
	unsigned long _watermark[NR_WMARK];
  
  /*é€šå¸¸ç”±é¡µåˆ†é…å™¨è®¿é—®çš„å­—æ®µ */
	/*unsigned long pages_min, pages_low, pages_high;*/
  
  /*
	 * We don't know if the memory that we're going to allocate will be
	 * freeable or/and it will be released eventually, so to avoid totally
	 * wasting several GB of ram we must reserve some of the lower zone
	 * memory (otherwise we risk to run OOM on the lower zones despite
	 * there being tons of freeable ram on the higher zones).  This array is
	 * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl
	 * changes.
	 */
	unsigned long lowmem_reserve[MAX_NR_ZONES];
	struct per_cpu_pageset pageset[NR_CPUS];
	/*
   * ä¸åŒé•¿åº¦çš„ç©ºé—²åŒºåŸŸ
   */
	spinlock_t lock;
	struct free_area free_area[NR_PAGE_ORDER];
	ZONE_PADDING(_pad1_)
	
  /* é€šå¸¸ç”±é¡µé¢æ”¶å›æ‰«æç¨‹åºè®¿é—®çš„å­—æ®µ */
	spinlock_t lru_lock;
	struct list_head active_list;
	struct list_head inactive_list;
	unsigned long nr_scan_active;
	unsigned long nr_scan_inactive;
	unsigned long pages_scanned; /* ä¸Šä¸€æ¬¡å›æ”¶ä»¥æ¥æ‰«æè¿‡çš„é¡µ */
	unsigned long flags; /* å†…å­˜åŸŸæ ‡å¿—ï¼Œè§ä¸‹æ–‡ */
	
	/* Write-intensive fields used by compaction and vmstats. */
	CACHELINE_PADDING(_pad2_);
  
  /* å†…å­˜åŸŸç»Ÿè®¡é‡ */
	atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS];
	int prev_priority;

/* å¾ˆå°‘ä½¿ç”¨æˆ–å¤§å¤šæ•°æƒ…å†µä¸‹åªè¯»çš„å­—æ®µ */
wait_queue_head_t * wait_table;
unsigned long wait_table_hash_nr_entries;
unsigned long wait_table_bits;
/* æ”¯æŒä¸è¿ç»­å†…å­˜æ¨¡å‹çš„å­—æ®µã€‚ */
struct pglist_data *zone_pgdat;
	unsigned long zone_start_pfn;
	unsigned long unsigned long spanned_pages; /* æ€»é•¿åº¦ï¼ŒåŒ…å«ç©ºæ´ */
	present_pages; /* å†…å­˜æ•°é‡ï¼ˆé™¤å»ç©ºæ´ï¼‰ */
	char *name;
} ____cacheline_maxaligned_in_smp;
```

è¡¥å……1:

>ä»`Linux`å†…æ ¸`v4.13`å¼€å§‹ï¼Œ`zone->pages_min`ç­‰å­—æ®µè¢«æ•´åˆè¿›äº†ä¸€ä¸ªæ–°çš„å­—æ®µï¼š
>
>```c
>unsigned long watermark[NR_WMARK];
>```
>
>-   `NR_WMARK`æ˜¯ä¸€ä¸ªæšä¸¾å€¼ï¼Œå®šä¹‰ä¸º3ï¼ˆåœ¨`include/linux/mmzone.h`ä¸­ï¼‰ï¼š
>
>    ```c
>    enum zone_watermarks {
>      WMARK_MIN,
>      WMARK_LOW,
>      WMARK_HIGH,
>      NR_WMARK
>    };
>    ```
>
>-   æ‰€ä»¥`zone->watermark[WMARK_MIN]`å°±ç›¸å½“äºåŸæ¥çš„`zone->pages_min`
>
>-   `zone->watermark[WMARK_LOW]`æ›¿ä»£äº†`pages_low`
>
>-   `zone->watermark[WMARK_HIGH]`æ›¿ä»£äº†`pages_high`

è¡¥å……2:

`zone->free_area[order]`

-   è¿™æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå¤§å°æ˜¯`MAX_ORDER`ï¼ˆé€šå¸¸æ˜¯ 11ï¼‰ï¼Œè¡¨ç¤ºä»$2^0$åˆ°$2^{10}$çš„é¡µå—ã€‚

-   æ¯ä¸€ä¸ª`zone->free_area[order]`é‡Œéƒ½å­˜å‚¨äº†è¯¥`order`ä¸‹çš„ç©ºé—²é¡µå—ã€‚

-   æ¯ä¸ª`free_list[migrate_type]`æ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œé“¾è¡¨é‡Œçš„å…ƒç´ æ˜¯`struct page`å¯¹è±¡ã€‚

è¯¥ç»“æ„å„ä¸ªæˆå‘˜çš„è¯­ä¹‰æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿç”±äºå†…å­˜ç®¡ç†æ˜¯å†…æ ¸ä¸­ä¸€ä¸ªå¤æ‚è€Œç‰µæ¶‰é¢‡å¹¿çš„éƒ¨åˆ†ï¼Œå› æ­¤åœ¨è¿™é‡Œå°†è¯¥ç»“æ„æ‰€æœ‰æˆå‘˜çš„ç¡®åˆ‡è¯­ä¹‰éƒ½è®²è§£æ¸…æ¥šæ˜¯ä¸å¤ªå¯èƒ½çš„ï¼Œæœ¬ç« å’Œåç»­ç« èŠ‚ç›¸å½“ä¸€éƒ¨åˆ†éƒ½ä¼šä¸“æ³¨äºè®²è¿°ç›¸å…³çš„æ•°æ®ç»“æ„å’Œæœºåˆ¶ã€‚æ­¤å¤„åªèƒ½å¯¹å³å°†è®¨è®ºçš„é—®é¢˜ç»™äºˆæ¦‚è¿°ï¼Œè¯»è€…å§‘ä¸”æµ…å°è¾„æ­¢ã€‚å°½ç®¡å¦‚æ­¤ï¼Œä»ç„¶ä¼šå‡ºç°å¤§é‡çš„å‘å‰å¼•ç”¨ã€‚

-   `pages_min`ã€`pages_high`ã€`pages_low`æ˜¯é¡µæ¢å‡ºæ—¶ä½¿ç”¨çš„â€œæ°´å°â€ã€‚å¦‚æœå†…å­˜ä¸è¶³ï¼Œå†…æ ¸å¯ä»¥å°†é¡µå†™åˆ°ç¡¬ç›˜ã€‚è¿™3ä¸ªæˆå‘˜ä¼šå½±å“äº¤æ¢å®ˆæŠ¤è¿›ç¨‹çš„è¡Œä¸ºã€‚

    -   å¦‚æœç©ºé—²é¡µå¤šäº`pages_high`ï¼Œåˆ™å†…å­˜åŸŸçš„çŠ¶æ€æ˜¯ç†æƒ³çš„ã€‚
    -   å¦‚æœç©ºé—²é¡µçš„æ•°ç›®ä½äº`pages_low`ï¼Œåˆ™å†…æ ¸å¼€å§‹å°†é¡µæ¢å‡ºåˆ°ç¡¬ç›˜ã€‚

    -   å¦‚æœç©ºé—²é¡µçš„æ•°ç›®ä½äº`pages_min`ï¼Œé‚£ä¹ˆé¡µå›æ”¶å·¥ä½œçš„å‹åŠ›å°±æ¯”è¾ƒå¤§ï¼Œå› ä¸ºå†…å­˜åŸŸä¸­æ€¥éœ€ç©ºé—²é¡µã€‚

-   `zone_start_pfn`æ˜¯å†…å­˜åŸŸç¬¬ä¸€ä¸ªé¡µå¸§çš„ç´¢å¼•ã€‚

å‡è®¾æœ‰è¿™å‡ ä¸ª`zone`ï¼š

-   `ZONE_DMA`
-   `ZONE_NORMAL`
-   `ZONE_HIGHMEM`

æ¯ä¸ª`zone`çš„`lowmem_reserve[]`å€¼å¯èƒ½æ˜¯ï¼š

| zone name | lowmem_reserve[DMA] | lowmem_reserve[NORMAL] | lowmem_reserve[HIGHMEM] |
| --------- | ------------------- | ---------------------- | ----------------------- |
| `DMA`     | 0                   | -                      | -                       |
| `NORMAL`  | 128                 | 0                      | -                       |
| `HIGHMEM` | 256                 | 128                    | 0                       |

è¿™æ„å‘³ç€ï¼š

-   ä»`HIGHMEM`åˆ†é…å†…å­˜æ—¶ï¼Œå¿…é¡»ä¿è¯ï¼š
    -   `HIGHMEM`è‡³å°‘å‰© 256 é¡µï¼ˆä¸º`NORMAL`ç•™ï¼‰
    -   `NORMAL`è‡³å°‘å‰© 128 é¡µï¼ˆä¸º`DMA`ç•™ï¼‰

å¦åˆ™ï¼Œå°±ä¸èƒ½ç»§ç»­ä»`HIGHMEM`åˆ†é…ã€‚

ğŸ§  ä¸ºä»€ä¹ˆéœ€è¦å®ƒï¼Ÿ

`Linux`çš„åˆ†é…å™¨ï¼ˆ`__alloc_pages()`ï¼‰æ˜¯ä»é«˜`zone`å‘ä½`zone`å›é€€çš„ã€‚

>   ä½†æˆ‘ä»¬å¿…é¡»ä¿ç•™ä½åœ°å€ç‰©ç†å†…å­˜ç”¨äºä¸€äº›â€œåªèƒ½ç”¨ä½åœ°å€å†…å­˜â€çš„åœºæ™¯ï¼Œå¦‚ï¼š
>
>   -   `DMA`è®¾å¤‡ï¼ˆåªèƒ½è®¿é—®`0~16MB`ï¼‰
>   -   é¡µè¡¨ã€å†…æ ¸æ ˆï¼ˆå¯èƒ½ä¸æ”¯æŒ`highmem`ï¼‰
>   -   `atomic`åˆ†é…

æ‰€ä»¥è¦å¼ºåˆ¶â€œé«˜`zone`ä¸å‡†æŠŠè‡ªå·±ç”¨å…‰â€ï¼Œä»¥ä¿è¯ä½`zone`æœ‰è¶³å¤Ÿèµ„æºã€‚

------

## âš™ï¸ é‚£å®ƒæ˜¯å¦‚ä½•å‚ä¸åˆ†é…çš„ï¼Ÿ

**watermark è®¡ç®—å…¬å¼ï¼ˆç®€åŒ–ç‰ˆï¼‰**ï¼š

```
c


å¤åˆ¶ç¼–è¾‘
watermark = pages_min + lowmem_reserve[zone_idx];
```

è¿™ä¸ª `watermark` ç”¨äºåˆ¤æ–­ï¼š

```
c


å¤åˆ¶ç¼–è¾‘
free_pages(zone) >= watermark ?
```

å¦‚æœä¸æ»¡è¶³ï¼Œå°±ä¸èƒ½ä»è¿™ä¸ª zone åˆ†é…ã€‚

------

## ğŸ“Œ å®é™…ä»£ç è·¯å¾„ï¼š

ä½ å¯ä»¥çœ‹åˆ°è¿™äº›é€»è¾‘å‡ºç°åœ¨ï¼š

-   `mm/page_alloc.c` ä¸­çš„ `zone_watermark_ok()`ã€`zone_watermark_fast()` ç­‰å‡½æ•°ï¼›
-   åˆ†é…å‡½æ•° `__alloc_pages_nodemask()` ä¸­è°ƒç”¨å®ƒæ¥åˆ¤æ–­èƒ½å¦ä»æŸä¸ª zone åˆ†é…ã€‚

-   ã€‚

------

## ğŸ”„ å¦‚ä½•åŠ¨æ€è°ƒæ•´ï¼Ÿ

è¿™ä¸ªæ•°ç»„ä¼šæ ¹æ® `/proc/sys/vm/lowmem_reserve_ratio` æ¥å®æ—¶æ›´æ–°ã€‚

ä¾‹å¦‚ï¼š

```
bash


å¤åˆ¶ç¼–è¾‘
cat /proc/sys/vm/lowmem_reserve_ratio
# è¾“å‡ºç±»ä¼¼äº: 256 256 32
```

ä½ å¯ä»¥æ‰‹åŠ¨è°ƒæ•´ï¼š

```
bash


å¤åˆ¶ç¼–è¾‘
echo "128 128 32" > /proc/sys/vm/lowmem_reserve_ratio
```

ä¹Ÿæœ‰å¯èƒ½è¿™äº›æ ‡å¿—å‡æœªè®¾ç½®ã€‚è¿™æ˜¯å†…å­˜åŸŸçš„æ­£å¸¸çŠ¶æ€ã€‚ZONE_ALL_UNRECLAIMABLEçŠ¶æ€å‡ºç°

åœ¨å†…æ ¸è¯•å›¾é‡ç”¨è¯¥å†…å­˜åŸŸçš„ä¸€äº›é¡µæ—¶ï¼ˆé¡µé¢å›æ”¶ï¼Œå‚è§ç¬¬18ç« ï¼‰ï¼Œä½†å› ä¸ºæ‰€æœ‰çš„é¡µéƒ½è¢«é’‰ä½

è€Œæ— æ³•å›æ”¶ã€‚ä¾‹å¦‚ï¼Œç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºå¯ä»¥ä½¿ç”¨mlockç³»ç»Ÿè°ƒç”¨é€šçŸ¥å†…æ ¸é¡µä¸èƒ½ä»ç‰©ç†å†…å­˜

ç§»å‡ºï¼Œæ¯”å¦‚æ¢å‡ºåˆ°ç£ç›˜ä¸Šã€‚è¿™æ ·çš„é¡µç§°ä¹‹ä¸ºé’‰ä½çš„ã€‚å¦‚æœä¸€ä¸ªå†…å­˜åŸŸä¸­çš„æ‰€æœ‰é¡µéƒ½è¢«é’‰ä½ï¼Œ

é‚£ä¹ˆè¯¥å†…å­˜åŸŸæ˜¯æ— æ³•å›æ”¶çš„ï¼Œå³è®¾ç½®è¯¥æ ‡å¿—ã€‚ä¸ºä¸æµªè´¹æ—¶é—´ï¼Œäº¤æ¢å®ˆæŠ¤è¿›ç¨‹åœ¨å¯»æ‰¾å¯ä¾›å›

æ”¶çš„é¡µæ—¶ï¼Œåªä¼šç®€è¦åœ°æ‰«æä¸€ä¸‹æ­¤ç±»å†…å­˜åŸŸã€‚â‘ 

åœ¨SMPç³»ç»Ÿä¸Šï¼Œå¤šä¸ªCPUå¯èƒ½è¯•å›¾å¹¶å‘åœ°å›æ”¶ä¸€ä¸ªå†…å­˜åŸŸã€‚ZONE_RECLAIM_LOCKEDæ ‡å¿—å¯é˜²

æ­¢è¿™ç§æƒ…å†µï¼šå¦‚æœä¸€ä¸ªCPUåœ¨å›æ”¶æŸä¸ªå†…å­˜åŸŸï¼Œåˆ™è®¾ç½®è¯¥æ ‡å¿—ã€‚è¿™é˜²æ­¢äº†å…¶ä»–CPUçš„å°è¯•ã€‚

ZONE_OOM_LOCKEDä¸“ç”¨äºæŸç§ä¸èµ°è¿çš„æƒ…å†µï¼šå¦‚æœè¿›ç¨‹æ¶ˆè€—äº†å¤§é‡çš„å†…å­˜ï¼Œè‡´ä½¿å¿…è¦çš„æ“

ä½œéƒ½æ— æ³•å®Œæˆï¼Œé‚£ä¹ˆå†…æ ¸ä¼šè¯•å›¾æ€æ­»æ¶ˆè€—å†…å­˜æœ€å¤šçš„è¿›ç¨‹ï¼Œä»¥è·å¾—æ›´å¤šçš„ç©ºé—²é¡µã€‚è¯¥æ ‡å¿—

å¯ä»¥é˜²æ­¢å¤šä¸ªCPUåŒæ—¶è¿›è¡Œè¿™ç§æ“ä½œã€‚

å†…æ ¸æä¾›äº†3ä¸ªè¾…åŠ©å‡½æ•°ç”¨äºæµ‹è¯•å’Œè®¾ç½®å†…å­˜åŸŸçš„æ ‡å¿—

3.   å†…å­˜åŸŸæ°´å°çš„è®¡ç®—

### **1. `setup_per_zone_pages_min()` çš„åŸå§‹ä½œç”¨**

è¯¥å‡½æ•°ç”¨äºåˆå§‹åŒ–æ¯ä¸ªå†…å­˜åŒºåŸŸï¼ˆ`struct zone`ï¼‰çš„ **`min`ã€`low`ã€`high` æ°´ä½å€¼**ï¼ˆwatermarksï¼‰ï¼Œè¿™äº›æ°´ä½ç”¨äºè§¦å‘å†…å­˜å›æ”¶ï¼ˆå¦‚ `kswapd`ï¼‰å’Œåˆ†é…å†³ç­–ã€‚

-   **`min`**ï¼šæœ€ä½ç©ºé—²é¡µé¢é˜ˆå€¼ï¼Œä½äºæ­¤å€¼ä¼šè§¦å‘ç›´æ¥å›æ”¶ï¼ˆ`direct reclaim`ï¼‰ã€‚
-   **`low`**ï¼šç›®æ ‡ç©ºé—²é¡µé¢é˜ˆå€¼ï¼Œ`kswapd` å¼‚æ­¥å›æ”¶å†…å­˜ç›´åˆ°è¾¾åˆ°æ­¤å€¼ã€‚
-   **`high`**ï¼šä¸Šé™é˜ˆå€¼ï¼Œ`kswapd` åœæ­¢å›æ”¶ã€‚

------

### **2. æ›¿ä»£æ–¹æ¡ˆï¼ˆæ–°å†…æ ¸ä¸­çš„å®ç°ï¼‰**

åœ¨è¾ƒæ–°å†…æ ¸ï¼ˆå¦‚ v5.x+ï¼‰ï¼Œæ°´ä½è®¡ç®—è¢«åˆ†æ•£åˆ°ä»¥ä¸‹æµç¨‹ä¸­ï¼š

#### **(1) `init_per_zone_wmark_min()`ï¼ˆéƒ¨åˆ†æ›¿ä»£ï¼‰**

-   **ä½œç”¨**ï¼šåˆå§‹åŒ– `zone->_watermark[WMARK_MIN]`ï¼ŒåŸºäºå…¨å±€å˜é‡ `min_free_kbytes`ï¼ˆé€šè¿‡ `/proc/sys/vm/min_free_kbytes` é…ç½®ï¼‰ã€‚

-   **è°ƒç”¨è·¯å¾„**ï¼š

    c

    ```
    start_kernel() 
      â†’ mm_init() 
        â†’ init_per_zone_wmark_min()  // è®¡ç®— MIN æ°´ä½
        â†’ setup_per_zone_lowmem_reserve()  // è®¾ç½® lowmem ä¿ç•™
    ```

#### **(2) `calculate_watermark()`ï¼ˆåŠ¨æ€è°ƒæ•´æ°´ä½ï¼‰**

-   **ä½œç”¨**ï¼šåŠ¨æ€è®¡ç®—æ°´ä½å€¼ï¼ˆå¦‚ `WMARK_LOW`ã€`WMARK_HIGH`ï¼‰ï¼ŒåŸºäºå½“å‰å†…å­˜å‹åŠ›å’Œ `min_free_kbytes`ã€‚
-   **è°ƒç”¨åœºæ™¯**ï¼š
    -   å†…å­˜çƒ­æ’æ‹”ï¼ˆ`hotplug`ï¼‰æ—¶ã€‚
    -   é€šè¿‡ `/proc/sys/vm/min_free_kbytes` ä¿®æ”¹é…ç½®æ—¶ã€‚

#### **(3) `zone_watermark_ok()` / `zone_watermark_fast()`**

-   **ä½œç”¨**ï¼šæ£€æŸ¥å½“å‰ Zone çš„æ°´ä½æ˜¯å¦æ»¡è¶³åˆ†é…è¯·æ±‚ï¼Œæ›¿ä»£äº†æ—§ç‰ˆä¸­ç¡¬ç¼–ç çš„æ°´ä½é€»è¾‘ã€‚

------

### **3. å…³é”®ä»£ç ç¤ºä¾‹ï¼ˆæ–°å†…æ ¸ï¼‰**

#### **æ°´ä½åˆå§‹åŒ–ï¼ˆ`mm/page_alloc.c`ï¼‰**

c

```
static void __init init_per_zone_wmark_min(void) {
    unsigned long lowmem_kbytes;
    int new_min_free_kbytes;

    lowmem_kbytes = nr_free_buffer_pages() * (PAGE_SIZE >> 10);
    new_min_free_kbytes = int_sqrt(lowmem_kbytes * 16);
    
    if (new_min_free_kbytes > 65536)
        new_min_free_kbytes = 65536;
    if (new_min_free_kbytes < 128)
        new_min_free_kbytes = 128;

    min_free_kbytes = new_min_free_kbytes;
    setup_per_zone_wmarks();  // è®¡ç®—å„ Zone çš„æ°´ä½
}
```

#### **æ°´ä½åŠ¨æ€è°ƒæ•´ï¼ˆ`mm/vmscan.c`ï¼‰**

c

```
void update_wmark_min(void) {
    calculate_watermark();
    refresh_zone_stat_thresholds();
}
```

------

### **4. ä¸ºä»€ä¹ˆè¢«æ›¿ä»£ï¼Ÿ**

1.  **æ¨¡å—åŒ–è®¾è®¡**ï¼šæ°´ä½è®¡ç®—æ‹†åˆ†ä¸ºæ›´å°çš„å‡½æ•°ï¼Œä¾¿äºç»´æŠ¤å’ŒåŠ¨æ€è°ƒæ•´ã€‚
2.  **åŠ¨æ€å“åº”**ï¼šæ”¯æŒè¿è¡Œæ—¶æ ¹æ®å†…å­˜å‹åŠ›è°ƒæ•´æ°´ä½ï¼ˆå¦‚é€šè¿‡ `sysctl`ï¼‰ã€‚
3.  **ä»£ç æ¸…æ™°æ€§**ï¼šæ—§ç‰ˆ `setup_per_zone_pages_min()` è€¦åˆäº†å¤šä¸ªé€»è¾‘ï¼Œæ–°ç‰ˆåˆ†ç¦»äº†åˆå§‹åŒ–å’ŒåŠ¨æ€æ›´æ–°ã€‚

------

### **5. æ£€æŸ¥å½“å‰æ°´ä½ï¼ˆè°ƒè¯•æ–¹æ³•ï¼‰**

-   **æŸ¥çœ‹ `/proc/zoneinfo`**ï¼š

    bash

    ```
    cat /proc/zoneinfo | grep -A 10 "Node 0" | grep -E "min|low|high"
    ```

-   **å†…æ ¸å‚æ•°è°ƒæ•´**ï¼š

    bash

    ```
    sysctl vm.min_free_kbytes=65536  # ä¿®æ”¹åè§¦å‘æ°´ä½é‡è®¡ç®—
    ```

------

### **æ€»ç»“**

-   **æ›¿ä»£å‡½æ•°**ï¼š`init_per_zone_wmark_min()` + `calculate_watermark()` + `setup_per_zone_wmarks()`ã€‚
-   **æ ¸å¿ƒå˜åŒ–**ï¼šä»é™æ€åˆå§‹åŒ–å˜ä¸ºåŠ¨æ€è®¡ç®—ï¼Œæ›´çµæ´»é€‚åº”å†…å­˜å‹åŠ›ã€‚
-   **å…³è”æœºåˆ¶**ï¼šæ°´ä½å€¼ä¸ `kswapd`ã€`direct reclaim`ã€`min_free_kbytes` ç´§å¯†ç›¸å…³ã€‚



è¿™ä¸ªç»“æ„ä½“ `struct per_cpu_pages` æ˜¯ Linux å†…æ ¸ä¸­ç”¨äºç®¡ç† **æ¯ CPU é¡µå¸§ç¼“å­˜ï¼ˆPer-CPU Page Frame Cache, PCPï¼‰** çš„å…³é”®æ•°æ®ç»“æ„ï¼Œä¸»è¦ç”¨äºä¼˜åŒ–å†…å­˜åˆ†é…æ€§èƒ½ï¼Œå‡å°‘å¯¹å…¨å±€é”çš„ç«äº‰ã€‚ä»¥ä¸‹æ˜¯å„å­—æ®µçš„è¯¦ç»†è§£é‡Šï¼š

------

### **1. æ ¸å¿ƒå­—æ®µè§£æ**

#### **(1) é”ä¸ä¿æŠ¤æœºåˆ¶**

-   **`spinlock_t lock`**
    ä¿æŠ¤ `lists` å’Œ `count` ç­‰å­—æ®µçš„è‡ªæ—‹é”ï¼Œç¡®ä¿å¤šæ ¸å¹¶å‘è®¿é—®æ—¶çš„å®‰å…¨æ€§ã€‚

#### **(2) é¡µé¢è®¡æ•°ä¸æ°´ä½æ§åˆ¶**

-   **`int count`**
    å½“å‰ CPU çš„ PCP åˆ—è¡¨ä¸­**æ€»é¡µé¢æ•°**ï¼ˆæ‰€æœ‰è¿ç§»ç±»å‹çš„é¡µé¢æ€»å’Œï¼‰ã€‚
-   **`int high`**
    **é«˜æ°´ä½çº¿**ï¼Œå½“ `count` è¶…è¿‡æ­¤å€¼æ—¶ï¼Œéœ€å°†å¤šä½™é¡µé¢è¿”è¿˜ç»™ä¼™ä¼´ç³»ç»Ÿï¼ˆBuddy Systemï¼‰ã€‚
-   **`int high_min` / `int high_max`**
    é«˜æ°´ä½çš„æœ€å°/æœ€å¤§å€¼ï¼ŒåŠ¨æ€è°ƒæ•´ `high` çš„è¾¹ç•Œï¼ˆé¿å…é¢‘ç¹å›æ”¶æˆ–å†…å­˜æµªè´¹ï¼‰ã€‚
-   **`int batch`**
    ä»ä¼™ä¼´ç³»ç»Ÿæ‰¹é‡æ·»åŠ æˆ–ç§»é™¤é¡µé¢æ—¶çš„**å—å¤§å°**ï¼ˆå‡å°‘é¢‘ç¹æ“ä½œçš„å¼€é”€ï¼‰ã€‚

#### **(3) åˆ†é…ä¸é‡Šæ”¾ç­–ç•¥**

-   **`u8 flags`**
    æ ‡å¿—ä½ï¼Œç”¨äºæ§åˆ¶ PCP çš„ç‰¹æ®Šè¡Œä¸ºï¼ˆå¦‚é¢„å¡«å……ç­–ç•¥ï¼‰ã€‚
-   **`u8 alloc_factor`**
    åˆ†é…æ—¶çš„**åŠ¨æ€ç¼©æ”¾å› å­**ï¼Œç”¨äºè°ƒæ•´ `batch` çš„å¤§å°ï¼Œé€‚åº”ä¸åŒè´Ÿè½½ã€‚
-   **`short free_count`**
    **è¿ç»­é‡Šæ”¾é¡µé¢çš„è®¡æ•°**ï¼Œç”¨äºä¼˜åŒ–æ‰¹é‡é‡Šæ”¾æ“ä½œï¼ˆé¿å…é¢‘ç¹é”ç«äº‰ï¼‰ã€‚

#### **(4) é¡µé¢é“¾è¡¨**

-   **`struct list_head lists[NR_PCP_LISTS]`**
    æŒ‰**è¿ç§»ç±»å‹**ï¼ˆ`MIGRATE_TYPES`ï¼‰åˆ†ç±»çš„é¡µé¢é“¾è¡¨ã€‚ä¾‹å¦‚ï¼š
    -   `MIGRATE_UNMOVABLE`ï¼ˆä¸å¯ç§»åŠ¨é¡µé¢ï¼Œå¦‚å†…æ ¸æ ˆï¼‰
    -   `MIGRATE_MOVABLE`ï¼ˆå¯ç§»åŠ¨é¡µé¢ï¼Œå¦‚ç”¨æˆ·æ€å†…å­˜ï¼‰
    -   `MIGRATE_RECLAIMABLE`ï¼ˆå¯å›æ”¶é¡µé¢ï¼Œå¦‚æ–‡ä»¶ç¼“å­˜ï¼‰

#### **(5) NUMA ç›¸å…³å­—æ®µ**

-   **`u8 expire`**
    ä»…åœ¨ `CONFIG_NUMA` å¯ç”¨æ—¶æœ‰æ•ˆï¼Œè¡¨ç¤ºè¿œç¨‹èŠ‚ç‚¹é¡µé¢ç¼“å­˜çš„**è¿‡æœŸæ—¶é—´**ï¼Œè¶…æ—¶åéœ€å›æ”¶ã€‚

5.   é¡µå¸§

é¡µå¸§ä»£è¡¨ç³»ç»Ÿå†…å­˜çš„æœ€å°å•ä½ï¼Œå¯¹å†…å­˜ä¸­çš„æ¯ä¸ªé¡µéƒ½ä¼šåˆ›å»ºstruct pageçš„ä¸€ä¸ªå®ä¾‹ã€‚å†…æ ¸ç¨‹åº

å‘˜éœ€è¦æ³¨æ„ä¿æŒè¯¥ç»“æ„å°½å¯èƒ½å°ï¼Œå› ä¸ºå³ä½¿åœ¨ä¸­ç­‰ç¨‹åº¦çš„å†…å­˜é…ç½®ä¸‹ï¼Œç³»ç»Ÿçš„å†…å­˜åŒæ ·ä¼šåˆ†è§£ä¸ºå¤§é‡

çš„é¡µã€‚ä¾‹å¦‚ï¼ŒIA-32ç³»ç»Ÿçš„æ ‡å‡†é¡µé•¿åº¦ä¸º4 KiBï¼Œåœ¨ä¸»å†…å­˜å¤§å°ä¸º384 MiBæ—¶ï¼Œå¤§çº¦å…±æœ‰100 000é¡µã€‚å°±

å½“ä»Šçš„æ ‡å‡†è€Œè¨€ï¼Œè¿™ä¸ªå®¹é‡ç®—ä¸ä¸Šå¾ˆå¤§ï¼Œä½†é¡µçš„æ•°ç›®å·²ç»éå¸¸å¯è§‚ã€‚

è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆå†…æ ¸å°½åŠ›ä¿æŒstruct pageå°½å¯èƒ½å°çš„åŸå› ã€‚åœ¨å…¸å‹ç³»ç»Ÿä¸­ï¼Œç”±äºé¡µçš„æ•°ç›®å·¨å¤§ï¼Œ

å› æ­¤å¯¹pageç»“æ„çš„å°æ”¹åŠ¨ï¼Œä¹Ÿå¯èƒ½å¯¼è‡´ä¿å­˜æ‰€æœ‰pageå®ä¾‹æ‰€éœ€çš„ç‰©ç†å†…å­˜æš´æ¶¨ã€‚

é¡µçš„å¹¿æ³›ä½¿ç”¨ï¼Œå¢åŠ äº†ä¿æŒç»“æ„é•¿åº¦çš„éš¾åº¦ï¼šå†…å­˜ç®¡ç†çš„è®¸å¤šéƒ¨åˆ†éƒ½ä½¿ç”¨é¡µï¼Œç”¨äºå„ç§ä¸åŒçš„ç”¨

é€”ã€‚å†…æ ¸çš„ä¸€ä¸ªéƒ¨åˆ†å¯èƒ½å®Œå…¨ä¾èµ–äºstruct pageæä¾›çš„ç‰¹å®šä¿¡æ¯ï¼Œè€Œè¯¥ä¿¡æ¯å¯¹å†…æ ¸çš„å¦ä¸€éƒ¨åˆ†å¯èƒ½

å®Œå…¨æ— ç”¨ï¼Œè¯¥éƒ¨åˆ†ä¾èµ–äºstruct pageæä¾›çš„å…¶ä»–ä¿¡æ¯ï¼Œè€Œè¿™éƒ¨åˆ†ä¿¡æ¯å¯¹å†…æ ¸çš„å…¶ä»–éƒ¨åˆ†ä¹Ÿå¯èƒ½æ˜¯å®Œ

å…¨æ— ç”¨çš„ï¼Œç­‰ç­‰ã€‚

Cè¯­è¨€çš„è”åˆå¾ˆé€‚åˆäºè¯¥é—®é¢˜ï¼Œå°½ç®¡å®ƒæœªèƒ½å¢åŠ struct pageçš„æ¸…æ™°ç¨‹åº¦ã€‚è€ƒè™‘ä¸€ä¸ªä¾‹å­ï¼šä¸€ä¸ª

ç‰©ç†å†…å­˜é¡µèƒ½å¤Ÿé€šè¿‡å¤šä¸ªåœ°æ–¹çš„ä¸åŒé¡µè¡¨æ˜ å°„åˆ°è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œå†…æ ¸æƒ³è¦è·Ÿè¸ªæœ‰å¤šå°‘åœ°æ–¹æ˜ å°„äº†è¯¥

é¡µã€‚ä¸ºæ­¤ï¼Œstruct pageä¸­æœ‰ä¸€ä¸ªè®¡æ•°å™¨ç”¨äºè®¡ç®—æ˜ å°„çš„æ•°ç›®ã€‚å¦‚æœä¸€é¡µç”¨äºslubåˆ†é…å™¨ï¼ˆå°†æ•´é¡µç»†

åˆ†ä¸ºæ›´å°éƒ¨åˆ†çš„ä¸€ç§æ–¹æ³•ï¼Œè¯·å‚è§3.6.1èŠ‚ï¼‰ï¼Œé‚£ä¹ˆå¯ä»¥ç¡®ä¿åªæœ‰å†…æ ¸ä¼šä½¿ç”¨è¯¥é¡µï¼Œè€Œä¸ä¼šæœ‰å…¶ä»–åœ°æ–¹

ä½¿ç”¨ï¼Œå› æ­¤æ˜ å°„è®¡æ•°ä¿¡æ¯å°±æ˜¯å¤šä½™çš„ã€‚å› æ­¤å†…æ ¸å¯ä»¥é‡æ–°è§£é‡Šè¯¥å­—æ®µï¼Œç”¨æ¥è¡¨ç¤ºè¯¥é¡µè¢«ç»†åˆ†ä¸ºå¤šå°‘ä¸ª

å°çš„å†…å­˜å¯¹è±¡ä½¿ç”¨ã€‚åœ¨æ•°æ®ç»“æ„å®šä¹‰ä¸­ï¼Œè¿™ç§åŒé‡è§£é‡Šå¦‚ä¸‹æ‰€ç¤ºï¼š

```c
struct page {
  unsigned long flags; /* Atomic flags, some possibly
                        * updated asynchronously */
  /*
   * Five words (20/40 bytes) are available in this union.
   * WARNING: bit 0 of the first word is used for PageTail(). That
   * means the other users of this union MUST NOT use the bit to
   * avoid collision and false-positive PageTail().
   */
  union {
    struct { /* Page cache and anonymous pages */
      /**
       * @lru: Pageout list, eg. active_list protected by
       * lruvec->lru_lock.  Sometimes used as a generic list
       * by the page owner.
       */
      union {
        struct list_head lru;

        /* Or, for the Unevictable "LRU list" slot */
        struct {
          /* Always even, to negate PageTail */
          void *__filler;
          /* Count page's or folio's mlocks */
          unsigned int mlock_count;
        };

        /* Or, free page */
        struct list_head buddy_list;
        struct list_head pcp_list;
        struct {
          struct llist_node pcp_llist;
          unsigned int order;
        };
      };
      /* See page-flags.h for PAGE_MAPPING_FLAGS */
      struct address_space *mapping;
      union {
        pgoff_t __folio_index; /* Our offset within mapping. */
        unsigned long share;   /* share count for fsdax */
      };
      /**
       * @private: Mapping-private opaque data.
       * Usually used for buffer_heads if PagePrivate.
       * Used for swp_entry_t if swapcache flag set.
       * Indicates order in the buddy system if PageBuddy.
       */
      unsigned long private;
    };
    struct { /* page_pool used by netstack */
      /**
       * @pp_magic: magic value to avoid recycling non
       * page_pool allocated pages.
       */
      unsigned long pp_magic;
      struct page_pool *pp;
      unsigned long _pp_mapping_pad;
      unsigned long dma_addr;
      atomic_long_t pp_ref_count;
    };
    struct {                       /* Tail pages of compound page */
      unsigned long compound_head; /* Bit zero is set */
    };
    struct { /* ZONE_DEVICE pages */
      /*
       * The first word is used for compound_head or folio
       * pgmap
       */
      void *_unused_pgmap_compound_head;
      void *zone_device_data;
      /*
       * ZONE_DEVICE private pages are counted as being
       * mapped so the next 3 words hold the mapping, index,
       * and private fields from the source anonymous or
       * page cache page while the page is migrated to device
       * private memory.
       * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also
       * use the mapping, index, and private fields when
       * pmem backed DAX files are mapped.
       */
    };

    /** @rcu_head: You can use this to free a page by RCU. */
    struct rcu_head rcu_head;
  };

  union { /* This union is 4 bytes in size. */
    /*
     * For head pages of typed folios, the value stored here
     * allows for determining what this page is used for. The
     * tail pages of typed folios will not store a type
     * (page_type == _mapcount == -1).
     *
     * See page-flags.h for a list of page types which are currently
     * stored here.
     *
     * Owners of typed folios may reuse the lower 16 bit of the
     * head page page_type field after setting the page type,
     * but must reset these 16 bit to -1 before clearing the
     * page type.
     */
    unsigned int page_type;

    /*
     * For pages that are part of non-typed folios for which mappings
     * are tracked via the RMAP, encodes the number of times this page
     * is directly referenced by a page table.
     *
     * Note that the mapcount is always initialized to -1, so that
     * transitions both from it and to it can be tracked, using
     * atomic_inc_and_test() and atomic_add_negative(-1).
     */
    atomic_t _mapcount;
  };

  /* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */
  atomic_t _refcount;

#ifdef CONFIG_MEMCG
  unsigned long memcg_data;
#elif defined(CONFIG_SLAB_OBJ_EXT)
  unsigned long _unused_slab_obj_exts;
#endif

  /*
   * On machines where all RAM is mapped into kernel address space,
   * we can simply calculate the virtual address. On machines with
   * highmem some memory is mapped into kernel virtual memory
   * dynamically, so we need a place to store that address.
   * Note that this field could be 16 bits on x86 ... ;)
   *
   * Architectures with slow multiplication can define
   * WANT_PAGE_VIRTUAL in asm/page.h
   */
#if defined(WANT_PAGE_VIRTUAL)
  void *virtual; /* Kernel virtual address (NULL if
                    not kmapped, ie. highmem) */
#endif           /* WANT_PAGE_VIRTUAL */

#ifdef LAST_CPUPID_NOT_IN_PAGE_FLAGS
  int _last_cpupid;
#endif

#ifdef CONFIG_KMSAN
  /*
   * KMSAN metadata for this page:
   *  - shadow page: every bit indicates whether the corresponding
   *    bit of the original page is initialized (0) or not (1);
   *  - origin page: every 4 bytes contain an id of the stack trace
   *    where the uninitialized value was created.
   */
  struct page *kmsan_shadow;
  struct page *kmsan_origin;
#endif
}
_struct_page_alignment;
```

è¯¥ç»“æ„çš„æ ¼å¼æ˜¯ä½“ç³»ç»“æ„æ— å…³çš„ï¼Œä¸ä¾èµ–äºä½¿ç”¨çš„CPUç±»å‹ï¼Œæ¯ä¸ªé¡µå¸§éƒ½ç”±è¯¥ç»“æ„æè¿°ã€‚é™¤äº†slub

ç›¸å…³æˆå‘˜ä¹‹å¤–ï¼Œpageç»“æ„ä¹ŸåŒ…å«äº†è‹¥å¹²å…¶ä»–æˆå‘˜ï¼Œåªèƒ½åœ¨è®¨è®ºç›¸å…³å†…æ ¸å­ç³»ç»Ÿæ—¶å‡†ç¡®åœ°è§£é‡Šã€‚

-   `flags`å­˜å‚¨äº†ä½“ç³»ç»“æ„æ— å…³çš„æ ‡å¿—ï¼Œç”¨äºæè¿°é¡µçš„å±æ€§ã€‚

-   `_mapcount`è¡¨ç¤ºåœ¨é¡µè¡¨ä¸­æœ‰å¤šå°‘é¡¹æŒ‡å‘è¯¥é¡µã€‚

-   å†…æ ¸å¯ä»¥å°†å¤šä¸ªæ¯—è¿çš„é¡µåˆå¹¶ä¸ºè¾ƒå¤§çš„å¤åˆé¡µï¼ˆ`compound page`ï¼‰ã€‚åˆ†ç»„ä¸­çš„ç¬¬ä¸€ä¸ªé¡µç§°ä½œé¦–é¡µï¼ˆ`head page`ï¼‰ ï¼Œè€Œæ‰€æœ‰å…¶ä½™å„é¡µå«åšå°¾é¡µï¼ˆ`tail page`ï¼‰ ã€‚æ‰€æœ‰å°¾é¡µå¯¹åº”çš„`page`å®ä¾‹ä¸­ï¼Œéƒ½å°†`first_page`è®¾ç½®ä¸ºæŒ‡å‘é¦–é¡µã€‚

-   `mapping`æŒ‡å®šäº†é¡µå¸§æ‰€åœ¨çš„åœ°å€ç©ºé—´ã€‚indexæ˜¯é¡µå¸§åœ¨æ˜ å°„å†…éƒ¨çš„åç§»é‡ã€‚åœ°å€ç©ºé—´æ˜¯ä¸€ä¸ªéå¸¸ä¸€èˆ¬çš„æ¦‚å¿µï¼Œä¾‹å¦‚ï¼Œå¯ä»¥ç”¨åœ¨å‘å†…å­˜è¯»å–æ–‡ä»¶æ—¶ã€‚åœ°å€ç©ºé—´ç”¨äºå°†æ–‡ä»¶çš„å†…å®¹ï¼ˆæ•°æ®ï¼‰ä¸è£…è½½æ•°æ®çš„å†…å­˜åŒºå…³è”èµ·æ¥ã€‚é€šè¿‡ä¸€ä¸ªå°æŠ€å·§ï¼Œ`mapping`ä¸ä»…èƒ½å¤Ÿä¿å­˜ä¸€ä¸ªæŒ‡é’ˆï¼Œè€Œä¸”è¿˜èƒ½åŒ…å«ä¸€äº›é¢å¤–çš„ä¿¡æ¯ï¼Œç”¨äºåˆ¤æ–­é¡µæ˜¯å¦å±äºæœªå…³è”åˆ°åœ°å€ç©ºé—´çš„æŸä¸ªåŒ¿åå†…å­˜åŒºã€‚å¦‚æœå°†`mapping`ç½®ä¸º1ï¼Œåˆ™è¯¥æŒ‡é’ˆå¹¶ä¸æŒ‡å‘`address_space`çš„å®ä¾‹ï¼Œè€Œæ˜¯æŒ‡å‘å¦ä¸€ä¸ªæ•°æ®ç»“æ„ï¼ˆ`anon_vma`ï¼‰ï¼Œè¯¥ç»“æ„å¯¹å®ç°åŒ¿åé¡µçš„é€†å‘æ˜ å°„å¾ˆé‡è¦ã€‚å¯¹è¯¥æŒ‡é’ˆçš„åŒé‡ä½¿ç”¨æ˜¯å¯èƒ½çš„ï¼Œå› ä¸º`address_space`å®ä¾‹æ€»æ˜¯å¯¹é½åˆ°`sizeof(long)`ã€‚å› æ­¤åœ¨`Linux`æ”¯æŒçš„æ‰€æœ‰è®¡ç®—æœºä¸Šï¼ŒæŒ‡å‘è¯¥å®ä¾‹çš„æŒ‡é’ˆæœ€ä½ä½æ€»æ˜¯0ã€‚è¯¥æŒ‡é’ˆå¦‚æœæŒ‡å‘`address_space`å®ä¾‹ï¼Œåˆ™å¯ä»¥ç›´æ¥ä½¿ç”¨ã€‚å¦‚æœä½¿ç”¨äº†æŠ€å·§å°†æœ€ä½ä½è®¾ç½®ä¸º1ï¼Œå†…æ ¸å¯ä½¿ç”¨ä¸‹åˆ—æ“ä½œæ¢å¤æ¥æ¢å¤æŒ‡é’ˆï¼š

    `anon_vma = (struct anon_vma *) (mapping -PAGE_MAPPING_ANON)`

-   `private`æ˜¯ä¸€ä¸ªæŒ‡å‘â€œç§æœ‰â€æ•°æ®çš„æŒ‡é’ˆï¼Œè™šæ‹Ÿå†…å­˜ç®¡ç†ä¼šå¿½ç•¥è¯¥æ•°æ®ã€‚

-    virtualç”¨äºé«˜ç«¯å†…å­˜åŒºåŸŸä¸­çš„é¡µï¼Œæ¢è¨€ä¹‹ï¼Œå³æ— æ³•ç›´æ¥æ˜ å°„åˆ°å†…æ ¸å†…å­˜ä¸­çš„é¡µã€‚virtualç”¨

    äºå­˜å‚¨è¯¥é¡µçš„è™šæ‹Ÿåœ°å€ã€‚

    æŒ‰ç…§é¢„å¤„ç†å™¨è¯­å¥#if defined(WANT_PAGE_VIRTUAL)ï¼Œåªæœ‰å®šä¹‰äº†å¯¹åº”çš„å®ï¼Œvirtualæ‰èƒ½

    æˆä¸ºstruct pageçš„ä¸€éƒ¨åˆ†ã€‚

é¡µçš„ä¸åŒå±æ€§é€šè¿‡ä¸€ç³»åˆ—é¡µæ ‡å¿—æè¿°ï¼Œå­˜å‚¨ä¸ºstruct pageçš„flagsæˆå‘˜ä¸­çš„å„ä¸ªæ¯”ç‰¹ä½ã€‚è¿™äº›

æ ‡å¿—ç‹¬ç«‹äºä½¿ç”¨çš„ä½“ç³»ç»“æ„ï¼Œå› è€Œæ— æ³•æä¾›ç‰¹å®šäºCPUæˆ–è®¡ç®—æœºçš„ä¿¡æ¯ï¼ˆè¯¥ä¿¡æ¯ä¿å­˜åœ¨é¡µè¡¨ä¸­ï¼Œè§ä¸‹

æ–‡å¯çŸ¥ï¼‰ã€‚

å„ä¸ªæ ‡å¿—æ˜¯ç”±page-flags.hä¸­çš„å®å®šä¹‰çš„ï¼Œæ­¤å¤–è¿˜ç”Ÿæˆäº†ä¸€äº›å®ï¼Œç”¨äºæ ‡å¿—çš„è®¾ç½®ã€åˆ é™¤ã€æŸ¥

è¯¢ã€‚è¿™æ ·åšæ—¶ï¼Œå†…æ ¸éµå®ˆäº†ä¸€ç§é€šç”¨çš„å‘½åæ–¹æ¡ˆã€‚

ä¾‹å¦‚ï¼ŒPG_lockedå¸¸æ•°å®šä¹‰äº†æ ‡å¿—ä¸­ç”¨äºæŒ‡å®šé¡µé”å®šä¸å¦çš„æ¯”ç‰¹ä½ç½®ã€‚ä¸‹åˆ—å®å¯ä»¥ç”¨æ¥æ“ä½œè¯¥ æ¯”

ç‰¹ä½ï¼š

ï± PageLockedæŸ¥è¯¢æ¯”ç‰¹ä½æ˜¯å¦ç½®ä½ï¼›

ï± SetPageLockedè®¾ç½®PG_lockedä½ï¼Œä¸è€ƒè™‘å…ˆå‰çš„çŠ¶æ€ï¼›

ï± TestSetPageLockedè®¾ç½®æ¯”ç‰¹ä½ï¼Œè€Œä¸”è¿”å›åŸå€¼ï¼›

ï± ClearPageLockedæ¸…é™¤æ¯”ç‰¹ä½ï¼Œä¸è€ƒè™‘å…ˆå‰çš„çŠ¶æ€ï¼›

ï± TestClearPageLockedæ¸…é™¤æ¯”ç‰¹ä½ï¼Œè¿”å›åŸå€¼ã€‚

å¯¹å…¶ä»–çš„é¡µæ ‡å¿—ï¼ŒåŒæ ·æœ‰ä¸€ç»„å®ç”¨æ¥æ“ä½œå¯¹åº”çš„æ¯”ç‰¹ä½ã€‚è¿™äº›å®çš„å®ç°æ˜¯åŸå­çš„ã€‚å°½ç®¡å…¶ä¸­ä¸€äº›

ç”±è‹¥å¹²è¯­å¥ç»„æˆï¼Œä½†ä½¿ç”¨äº†ç‰¹æ®Šçš„å¤„ç†å™¨å‘½ä»¤ï¼Œç¡®ä¿å…¶è¡Œä¸ºå¦‚åŒå•ä¸€çš„è¯­å¥ã€‚å³è¿™äº›è¯­å¥æ˜¯æ— æ³•ä¸­æ–­

çš„ï¼Œå¦åˆ™ä¼šå¯¼è‡´ç«æ€æ¡ä»¶ã€‚ç¬¬5ç« è®²è¿°äº†ç«æ€æ¡ä»¶æ˜¯å¦‚ä½•å‡ºç°çš„ï¼Œä»¥åŠå¦‚ä½•é˜²æ­¢ã€‚

æœ‰å“ªäº›é¡µæ ‡å¿—å¯ç”¨ï¼Ÿä»¥ä¸‹åˆ—å‡ºäº†æœ€é‡è¦çš„æ ‡å¿—ï¼ˆå…¶å«ä¹‰åœ¨ä»¥åå‡ ç« é‡Œä¼šå˜å¾—æ¸…æ¥šä¸€äº›ï¼‰ã€‚

ï± PG_lockedæŒ‡å®šäº†é¡µæ˜¯å¦é”å®šã€‚å¦‚æœè¯¥æ¯”ç‰¹ä½ç½®ä½ï¼Œå†…æ ¸çš„å…¶ä»–éƒ¨åˆ†ä¸å…è®¸è®¿é—®è¯¥é¡µã€‚è¿™é˜²æ­¢

äº†å†…å­˜ç®¡ç†å‡ºç°ç«æ€æ¡ä»¶ï¼Œä¾‹å¦‚ï¼Œåœ¨ä»ç¡¬ç›˜è¯»å–æ•°æ®åˆ°é¡µå¸§æ—¶ã€‚

ï± å¦‚æœåœ¨æ¶‰åŠè¯¥é¡µçš„I/Oæ“ä½œæœŸé—´å‘ç”Ÿé”™è¯¯ï¼Œåˆ™PG_errorç½®ä½ã€‚

ï± PG_referencedå’ŒPG_activeæ§åˆ¶äº†ç³»ç»Ÿä½¿ç”¨è¯¥é¡µçš„æ´»è·ƒç¨‹åº¦ã€‚åœ¨é¡µäº¤æ¢å­ç³»ç»Ÿé€‰æ‹©æ¢å‡ºé¡µ

æ—¶ï¼Œè¯¥ä¿¡æ¯æ˜¯å¾ˆé‡è¦çš„ã€‚è¿™ä¸¤ä¸ªæ ‡å¿—çš„äº¤äº’å°†åœ¨ç¬¬18ç« è§£é‡Šã€‚

ï± PG_uptodateè¡¨ç¤ºé¡µçš„æ•°æ®å·²ç»ä»å—è®¾å¤‡è¯»å–ï¼Œå…¶é—´æ²¡æœ‰å‡ºé”™ã€‚

ï± å¦‚æœä¸ç¡¬ç›˜ä¸Šçš„æ•°æ®ç›¸æ¯”ï¼Œé¡µçš„å†…å®¹å·²ç»æ”¹å˜ï¼Œåˆ™ç½®ä½PG_dirtyã€‚å‡ºäºæ€§èƒ½è€ƒè™‘ï¼Œé¡µå¹¶ä¸åœ¨

æ¯æ¬¡æ”¹å˜åç«‹å³å›å†™ã€‚å› æ­¤å†…æ ¸ä½¿ç”¨è¯¥æ ‡å¿—æ³¨æ˜é¡µå·²ç»æ”¹å˜ï¼Œå¯ä»¥åœ¨ç¨ååˆ·å‡ºã€‚

è®¾ç½®äº†è¯¥æ ‡å¿—çš„é¡µç§°ä¸ºè„çš„ï¼ˆé€šå¸¸ï¼Œè¯¥æ„å‘³ç€å†…å­˜ä¸­çš„æ•°æ®æ²¡æœ‰ä¸å¤–å­˜å‚¨å™¨ä»‹è´¨å¦‚ç¡¬ç›˜ä¸Šçš„

æ•°æ®åŒæ­¥ï¼‰ã€‚

ï± PG_lruæœ‰åŠ©äºå®ç°é¡µé¢å›æ”¶å’Œåˆ‡æ¢ã€‚å†…æ ¸ä½¿ç”¨ä¸¤ä¸ªæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼ˆleast recently usedï¼Œlruï¼‰é“¾

è¡¨â‘ æ¥åŒºåˆ«æ´»åŠ¨å’Œä¸æ´»åŠ¨é¡µã€‚å¦‚æœé¡µåœ¨å…¶ä¸­ä¸€ä¸ªé“¾è¡¨ä¸­ï¼Œåˆ™è®¾ç½®è¯¥æ¯”ç‰¹ä½ã€‚è¿˜æœ‰ä¸€ä¸ªPG_active

æ ‡å¿—ï¼Œå¦‚æœé¡µåœ¨æ´»åŠ¨é¡µé“¾è¡¨ä¸­ï¼Œåˆ™è®¾ç½®è¯¥æ ‡å¿—ã€‚ç¬¬18ç« è¯¦ç»†è®¨è®ºäº†è¿™ä¸€é‡è¦æœºåˆ¶ã€‚

ï± PG_highmemè¡¨ç¤ºé¡µåœ¨é«˜ç«¯å†…å­˜ä¸­ï¼Œæ— æ³•æŒä¹…æ˜ å°„åˆ°å†…æ ¸å†…å­˜ä¸­ã€‚

ï± å¦‚æœpageç»“æ„çš„privateæˆå‘˜éç©ºï¼Œåˆ™å¿…é¡»è®¾ç½®PG_privateä½ã€‚ç”¨äºI/Oçš„é¡µï¼Œå¯ä½¿ç”¨è¯¥å­—æ®µ

å°†é¡µç»†åˆ†ä¸ºå¤šä¸ªç¼“å†²åŒºï¼ˆæ›´å¤šä¿¡æ¯è¯·å‚è§ç¬¬16ç« ï¼‰ï¼Œä½†å†…æ ¸çš„å…¶ä»–éƒ¨åˆ†ä¹Ÿæœ‰å„ç§ä¸åŒçš„æ–¹æ³•ï¼Œ

å°†ç§æœ‰æ•°æ®é™„åŠ åˆ°é¡µä¸Šã€‚

ï± å¦‚æœé¡µçš„å†…å®¹å¤„äºå‘å—è®¾å¤‡å›å†™çš„è¿‡ç¨‹ä¸­ï¼Œåˆ™éœ€è¦è®¾ç½®PG_writebackä½ã€‚

ï± å¦‚æœé¡µæ˜¯3.6èŠ‚è®¨è®ºçš„slabåˆ†é…å™¨çš„ä¸€éƒ¨åˆ†ï¼Œåˆ™è®¾ç½®PG_slabä½ã€‚

ï± å¦‚æœé¡µå¤„äºäº¤æ¢ç¼“å­˜ï¼Œåˆ™è®¾ç½®PG_swapcacheä½ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒprivateåŒ…å«ä¸€ä¸ªç±»å‹ä¸º

swap_entry_tçš„é¡¹ï¼ˆæ›´å¤šä¿¡æ¯è¯·å‚è§ç¬¬18ç« ï¼‰ã€‚

ï± åœ¨å¯ç”¨å†…å­˜çš„æ•°é‡å˜å°‘æ—¶ï¼Œå†…æ ¸è¯•å›¾å‘¨æœŸæ€§åœ°å›æ”¶é¡µï¼Œå³å‰”é™¤ä¸æ´»åŠ¨ã€æœªç”¨çš„é¡µã€‚ç¬¬18ç« è®¨

è®ºäº†ç›¸å…³ç»†èŠ‚ã€‚åœ¨å†…æ ¸å†³å®šå›æ”¶æŸä¸ªç‰¹å®šçš„é¡µä¹‹åï¼Œéœ€è¦è®¾ç½®PG_reclaimæ ‡å¿—é€šçŸ¥ã€‚

ï± å¦‚æœé¡µç©ºé—²ä¸”åŒ…å«åœ¨ä¼™ä¼´ç³»ç»Ÿçš„åˆ—è¡¨ä¸­ï¼Œåˆ™è®¾ç½®PG_buddyä½ï¼Œä¼™ä¼´ç³»ç»Ÿæ˜¯é¡µåˆ†é…æœºåˆ¶çš„æ ¸å¿ƒã€‚

ï± PG_compoundè¡¨ç¤ºè¯¥é¡µå±äºä¸€ä¸ªæ›´å¤§çš„å¤åˆé¡µï¼Œå¤åˆé¡µç”±å¤šä¸ªæ¯—è¿çš„æ™®é€šé¡µç»„æˆã€‚

å†…æ ¸å®šä¹‰äº†ä¸€äº›æ ‡å‡†å®ï¼Œç”¨äºæ£€æŸ¥é¡µæ˜¯å¦è®¾ç½®äº†æŸä¸ªç‰¹å®šçš„æ¯”ç‰¹ä½ï¼Œæˆ–è€…æ“ä½œæŸä¸ªæ¯”ç‰¹ä½ã€‚è¿™äº›

å®çš„åç§°æœ‰ä¸€å®šçš„æ¨¡å¼ï¼Œå¦‚ä¸‹æ‰€è¿°ã€‚

ï± PageXXX(page)ä¼šæ£€æŸ¥é¡µæ˜¯å¦è®¾ç½®äº†PG_XXXä½ã€‚ä¾‹å¦‚ï¼ŒPageDirtyæ£€æŸ¥PG_dirtyä½ï¼Œè€ŒPage-

Activeæ£€æŸ¥PG_activeä½ï¼Œç­‰ç­‰ã€‚

ï± SetPageXXXåœ¨æŸä¸ªæ¯”ç‰¹ä½æ²¡æœ‰è®¾ç½®çš„æƒ…å†µä¸‹ï¼Œè®¾ç½®è¯¥æ¯”ç‰¹ä½ï¼Œå¹¶è¿”å›åŸå€¼ã€‚

ï± ClearPageXXXæ— æ¡ä»¶åœ°æ¸…é™¤æŸä¸ªç‰¹å®šçš„æ¯”ç‰¹ä½ã€‚

ï± TestClearPageXXXæ¸…é™¤æŸä¸ªè®¾ç½®çš„æ¯”ç‰¹ä½ï¼Œå¹¶è¿”å›åŸå€¼ã€‚



##### 3.3 é¡µè¡¨

åœ¨ä»¥åå‡ èŠ‚é‡Œæè¿°çš„æ•°æ®ç»“æ„å’Œå‡½æ•°ï¼Œé€šå¸¸åŸºäºä½“ç³»ç»“æ„ç›¸å…³çš„æ–‡ä»¶ä¸­æä¾›çš„æ¥å£ã€‚å®šä¹‰å¯ä»¥åœ¨

å¤´æ–‡ä»¶include/asm-arch/page.hå’Œinclude/asm-arch/pgtable.hä¸­æ‰¾åˆ°ï¼Œä¸‹æ–‡ç®€ç§°ä¸ºpage.hå’Œ

pgtable.hã€‚è™½ç„¶AMD64å’ŒIA-32å·²ç»ç»Ÿä¸€ä¸ºä¸€ä¸ªä½“ç³»ç»“æ„ï¼Œä½†åœ¨å¤„ç†é¡µè¡¨æ–¹é¢ä»ç„¶æœ‰å¾ˆå¤§å·®åˆ«ï¼Œå› 

æ­¤ç›¸å…³çš„å®šä¹‰åˆ†ä¸ºä¸¤ä¸ªä¸åŒçš„æ–‡ä»¶ï¼š include/asm-x86/page_32.hå’Œinclude/asm-x86/page_64.hï¼Œ

ç±»ä¼¼åœ°æœ‰pgtable_XX.hã€‚

###### 3.3.1 æ•°æ®ç»“æ„

åœ¨Cè¯­è¨€ä¸­ï¼Œvoid *æ•°æ®ç±»å‹ç”¨äºå®šä¹‰å¯èƒ½æŒ‡å‘å†…å­˜ä¸­ä»»ä½•å­—èŠ‚ä½ç½®çš„æŒ‡é’ˆã€‚è¯¥ç±»å‹æ‰€éœ€çš„æ¯”ç‰¹

ä½æ•°ç›®ä¾ä¸åŒä½“ç³»ç»“æ„è€Œä¸åŒã€‚æ‰€æœ‰å¸¸è§çš„å¤„ç†å™¨ï¼ˆåŒ…æ‹¬Linuxæ”¯æŒçš„æ‰€æœ‰å¤„ç†å™¨ï¼‰éƒ½ä½¿ç”¨32ä½æˆ–64ä½ã€‚

å†…æ ¸æºä»£ç å‡å®švoid *å’Œunsigned longç±»å‹æ‰€éœ€çš„æ¯”ç‰¹ä½æ•°ç›¸åŒï¼Œå› æ­¤å®ƒä»¬ä¹‹é—´å¯ä»¥è¿›è¡Œå¼ºåˆ¶

è½¬æ¢è€Œä¸æŸå¤±ä¿¡æ¯ã€‚è¯¥å‡å®šçš„å½¢å¼è¡¨ç¤ºä¸ºsizeof(void *) == sizeof(unsigned long)ï¼Œåœ¨Linux

æ”¯æŒçš„æ‰€æœ‰ä½“ç³»ç»“æ„ä¸Šéƒ½æ˜¯æ­£ç¡®çš„ã€‚

å†…å­˜ç®¡ç†æ›´å–œæ¬¢ä½¿ç”¨unsigned longç±»å‹çš„å˜é‡ï¼Œ è€Œä¸æ˜¯voidæŒ‡é’ˆï¼Œå› ä¸ºå‰è€…æ›´æ˜“äºå¤„ç†å’Œæ“ä½œã€‚

æŠ€æœ¯ä¸Šï¼Œå®ƒä»¬éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚



##### 3.4 åˆå§‹åŒ–å†…å­˜ç®¡ç†

åœ¨å†…å­˜ç®¡ç†çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œåˆå§‹åŒ–ï¼ˆinitializationï¼‰å¯ä»¥æœ‰å¤šç§å«ä¹‰ã€‚åœ¨è®¸å¤šCPUä¸Šï¼Œå¿…é¡»æ˜¾å¼è®¾ç½®

é€‚äºLinuxå†…æ ¸çš„å†…å­˜æ¨¡å‹ã€‚ä¾‹å¦‚ï¼Œåœ¨IA-32ç³»ç»Ÿä¸Šéœ€è¦åˆ‡æ¢åˆ°ä¿æŠ¤æ¨¡å¼ï¼Œç„¶åå†…æ ¸æ‰èƒ½æ£€æµ‹å¯ç”¨å†…å­˜

å’Œå¯„å­˜å™¨ã€‚åœ¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼Œè¿˜å¿…é¡»å»ºç«‹å†…å­˜ç®¡ç†çš„æ•°æ®ç»“æ„ï¼Œä»¥åŠå…¶ä»–å¾ˆå¤šäº‹åŠ¡ã€‚å› ä¸ºå†…æ ¸åœ¨å†…å­˜

ç®¡ç†å®Œå…¨åˆå§‹åŒ–ä¹‹å‰å°±éœ€è¦ä½¿ç”¨å†…å­˜ï¼Œåœ¨ç³»ç»Ÿå¯åŠ¨è¿‡ç¨‹æœŸé—´ï¼Œä½¿ç”¨äº†ä¸€ä¸ªé¢å¤–çš„ç®€åŒ–å½¢å¼çš„å†…å­˜ç®¡ç†

æ¨¡å—ï¼Œç„¶ååˆä¸¢å¼ƒæ‰ã€‚

å› ä¸ºå†…å­˜ç®¡ç†åˆå§‹åŒ–ä¸­ç‰¹å®šäºCPUçš„éƒ¨åˆ†ä½¿ç”¨äº†åº•å±‚ä½“ç³»ç»“æ„è®¸å¤šæ¬¡è¦ã€å¾®å¦™çš„ç»†èŠ‚ï¼Œè¿™äº›ä¸å†…

æ ¸çš„ç»“æ„æ²¡ä»€ä¹ˆå…³ç³»ï¼Œæœ€å¤šä¸è¿‡æ˜¯æ±‡ç¼–è¯­è¨€ç¨‹åºè®¾è®¡çš„æœ€ä½³å®è·µè€Œå·²ï¼Œå› æ­¤æˆ‘ä»¬åœ¨æœ¬èŠ‚ä¸­åªæ˜¯ä»ä¸€ä¸ªæ¯”è¾ƒé«˜çš„å±‚æ¬¡æ¥è€ƒè™‘åˆå§‹åŒ–ç›¸å…³çš„å·¥ä½œã€‚å…³é”®æ˜¯pg_data_tæ•°æ®ç»“æ„çš„åˆå§‹åŒ–

###### 3.4.1 å»ºç«‹æ•°æ®ç»“æ„

å¯¹ç›¸å…³æ•°æ®ç»“æ„çš„åˆå§‹åŒ–æ˜¯ä»å…¨å±€å¯åŠ¨ä¾‹ç¨‹start_kernelä¸­å¼€å§‹çš„ï¼Œè¯¥ä¾‹ç¨‹åœ¨åŠ è½½å†…æ ¸å¹¶æ¿€æ´»

å„ä¸ªå­ç³»ç»Ÿä¹‹åæ‰§è¡Œã€‚ç”±äºå†…å­˜ç®¡ç†æ˜¯å†…æ ¸ä¸€ä¸ªéå¸¸é‡è¦çš„éƒ¨åˆ†ï¼Œå› æ­¤åœ¨ç‰¹å®šäºä½“ç³»ç»“æ„çš„è®¾ç½®æ­¥éª¤

ä¸­æ£€æµ‹å†…å­˜å¹¶ç¡®å®šç³»ç»Ÿä¸­å†…å­˜çš„åˆ†é…æƒ…å†µåï¼Œä¼šç«‹å³æ‰§è¡Œå†…å­˜ç®¡ç†çš„åˆå§‹åŒ–ï¼ˆ3.4.2èŠ‚ä»¥IA-32ç³»ç»Ÿä¸º

ä¾‹ï¼Œç®€è¦æè¿°äº†åˆå§‹åŒ–ä¸­ç³»ç»Ÿç›¸å…³éƒ¨åˆ†çš„å®ç°ï¼‰ã€‚æ­¤æ—¶ï¼Œå·²ç»å¯¹å„ç§ç³»ç»Ÿå†…å­˜æ¨¡å¼ç”Ÿæˆäº†ä¸€ä¸ªpgdata_t

å®ä¾‹ï¼Œç”¨äºä¿å­˜è¯¸å¦‚ç»“ç‚¹ä¸­å†…å­˜æ•°é‡ä»¥åŠå†…å­˜åœ¨å„ä¸ªå†…å­˜åŸŸä¹‹é—´åˆ†é…æƒ…å†µçš„ä¿¡æ¯ã€‚æ‰€æœ‰å¹³å°ä¸Šéƒ½å®ç°

äº†ç‰¹å®šäºä½“ç³»ç»“æ„çš„NODE_DATAå®ï¼Œç”¨äºé€šè¿‡ç»“ç‚¹ç¼–å·ï¼Œæ¥æŸ¥è¯¢ä¸ä¸€ä¸ªNUMAç»“ç‚¹ç›¸å…³çš„pgdata_t

å®ä¾‹ã€‚

1.   å…ˆå†³æ¡ä»¶

ç”±äºå¤§éƒ¨åˆ†ç³»ç»Ÿéƒ½åªæœ‰ä¸€ä¸ªå†…å­˜ç»“ç‚¹ï¼Œä¸‹æ–‡åªè€ƒå¯Ÿæ­¤ç±»ç³»ç»Ÿã€‚å…·ä½“æ˜¯ä»€ä¹ˆæ ·çš„æƒ…å†µå‘¢ï¼Ÿä¸ºç¡®ä¿å†…

å­˜ç®¡ç†ä»£ç æ˜¯å¯ç§»æ¤çš„ï¼ˆå› æ­¤å®ƒå¯ä»¥åŒæ ·ç”¨äºUMAå’ŒNUMAç³»ç»Ÿï¼‰ï¼Œå†…æ ¸åœ¨mm/page_alloc.cä¸­å®šä¹‰

äº†ä¸€ä¸ªpg_data_tå®ä¾‹ï¼ˆç§°ä½œcontig_page_dataï¼‰ç®¡ç†æ‰€æœ‰çš„ç³»ç»Ÿå†…å­˜ã€‚æ ¹æ®è¯¥æ–‡ä»¶çš„è·¯å¾„åå¯ä»¥

çœ‹å‡ºï¼Œè¿™ä¸æ˜¯ç‰¹å®šäºCPUçš„å®ç°ã€‚å®é™…ä¸Šï¼Œå¤§å¤šæ•°ä½“ç³»ç»“æ„éƒ½é‡‡ç”¨äº†è¯¥æ–¹æ¡ˆã€‚NODE_DATAçš„å®ç°ç°åœ¨

æ›´ç®€å•äº†ã€‚

```c
/* file: include/linux/numa.h */
extern struct pglist_data *node_data[];
#define NODE_DATA(nid)	(node_data[nid])

/* file: include/linux/mmzone.h */
extern struct pglist_data contig_page_data;
static inline struct pglist_data *NODE_DATA(int nid)
{
	return &contig_page_data;
}
```

ç®€å•äº†ã€‚

<mmzone.h>

\#define NODE_DATA(nid) (&contig_page_data)

å°½ç®¡è¯¥å®æœ‰ä¸€ä¸ªå½¢å¼å‚æ•°ç”¨äºé€‰æ‹©NUMAç»“ç‚¹ï¼Œä½†åœ¨UMAç³»ç»Ÿä¸­åªæœ‰ä¸€ä¸ªä¼ªç»“ç‚¹ï¼Œå› æ­¤æ€»æ˜¯è¿”

å›åŒæ ·çš„æ•°æ®ã€‚

å†…æ ¸ä¹Ÿå¯ä»¥ä¾èµ–äºä¸‹è¿°äº‹å®ï¼šä½“ç³»ç»“æ„ç›¸å…³çš„åˆå§‹åŒ–ä»£ç å°†numnodeså˜é‡è®¾ç½®ä¸ºç³»ç»Ÿä¸­ç»“ç‚¹çš„

æ•°ç›®ã€‚åœ¨UMAç³»ç»Ÿä¸Šå› ä¸ºåªæœ‰ä¸€ä¸ªï¼ˆå½¢å¼ä¸Šçš„ï¼‰ç»“ç‚¹ï¼Œå› æ­¤è¯¥æ•°é‡æ˜¯1ã€‚

åœ¨ç¼–è¯‘æ—¶é—´ï¼Œé¢„å¤„ç†å™¨è¯­å¥ä¼šä¸ºç‰¹å®šçš„é…ç½®é€‰æ‹©æ­£ç¡®çš„å®šä¹‰ã€‚

ï± setup_archæ˜¯ä¸€ä¸ªç‰¹å®šäºä½“ç³»ç»“æ„çš„è®¾ç½®å‡½æ•°ï¼Œå…¶ä¸­ä¸€é¡¹ä»»åŠ¡æ˜¯è´Ÿè´£åˆå§‹åŒ–è‡ªä¸¾åˆ†é…å™¨ã€‚

ï± åœ¨SMPç³»ç»Ÿä¸Šï¼Œ setup_per_cpu_areasåˆå§‹åŒ–æºä»£ç ä¸­ï¼ˆä½¿ç”¨per_cpuå®ï¼‰ å®šä¹‰çš„é™æ€per-cpu

å˜é‡ï¼Œè¿™ç§å˜é‡å¯¹ç³»ç»Ÿä¸­çš„æ¯ä¸ªCPUéƒ½æœ‰ä¸€ä¸ªç‹¬ç«‹çš„å‰¯æœ¬ã€‚æ­¤ç±»å˜é‡ä¿å­˜åœ¨å†…æ ¸äºŒè¿›åˆ¶æ˜ åƒçš„

ä¸€ä¸ªç‹¬ç«‹çš„æ®µä¸­ã€‚setup_per_cpu_areasçš„ç›®çš„æ˜¯ä¸ºç³»ç»Ÿçš„å„ä¸ªCPUåˆ†åˆ«åˆ›å»ºä¸€ä»½è¿™äº›æ•°æ®

çš„å‰¯æœ¬ã€‚

åœ¨éSMPç³»ç»Ÿä¸Šè¯¥å‡½æ•°æ˜¯ä¸€ä¸ªç©ºæ“ä½œã€‚

```c
/*
 * unless system_state == SYSTEM_BOOTING.
 *
 * __ref due to call of __init annotated helper build_all_zonelists_init
 * [protected by SYSTEM_BOOTING].
 */
void __ref build_all_zonelists(pg_data_t *pgdat)
{
	unsigned long vm_total_pages;

	if (system_state == SYSTEM_BOOTING) {
		build_all_zonelists_init();
	} else {
		__build_all_zonelists(pgdat);
		/* cpuset refresh routine should be here */
	}
	/* Get the number of free pages beyond high watermark in all zones. */
	vm_total_pages = nr_free_zone_pages(gfp_zone(GFP_HIGHUSER_MOVABLE));
	/*
	 * Disable grouping by mobility if the number of pages in the
	 * system is too low to allow the mechanism to work. It would be
	 * more accurate, but expensive to check per-zone. This check is
	 * made on memory-hotadd so a system can start with mobility
	 * disabled and enable it later
	 */
	if (vm_total_pages < (pageblock_nr_pages * MIGRATE_TYPES))
		page_group_by_mobility_disabled = 1;
	else
		page_group_by_mobility_disabled = 0;

	pr_info("Built %u zonelists, mobility grouping %s.  Total pages: %ld\n",
		nr_online_nodes,
		str_off_on(page_group_by_mobility_disabled),
		vm_total_pages);
#ifdef CONFIG_NUMA
	pr_info("Policy zone: %s\n", zone_names[policy_zone]);
#endif
}
```





ä»¬å›åˆ°å»ºç«‹å†…å­˜åŸŸåˆ—è¡¨çš„å·¥ä½œã€‚build_all_zonelists_initä¸­æˆ‘ä»¬å½“å‰æ„Ÿå…´è¶£çš„é‚£éƒ¨åˆ†ï¼ˆå¯¹äºé¡µåˆ†

é…å™¨çš„é¡µç»„å¯ç§»åŠ¨æ€§æ‰©å±•ï¼Œå®é™…ä¸Šè¿˜æœ‰å¦å¤–ä¸€äº›å·¥ä½œï¼Œæˆ‘ä¼šåœ¨ä¸‹æ–‡å•ç‹¬è®¨è®ºï¼‰å°†æ‰€æœ‰å·¥ä½œéƒ½å§”æ‰˜ç»™

__build_all_zonelistsï¼Œåè€…åˆå¯¹ç³»ç»Ÿä¸­çš„å„ä¸ªNUMAç»“ç‚¹åˆ†åˆ«è°ƒç”¨build_zonelistsã€‚



```c
static void __build_all_zonelists(void *data)
{
	int nid;
	int __maybe_unused cpu;
	pg_data_t *self = data;
	unsigned long flags;

	/*
	 * The zonelist_update_seq must be acquired with irqsave because the
	 * reader can be invoked from IRQ with GFP_ATOMIC.
	 */
	write_seqlock_irqsave(&zonelist_update_seq, flags);
	/*
	 * Also disable synchronous printk() to prevent any printk() from
	 * trying to hold port->lock, for
	 * tty_insert_flip_string_and_push_buffer() on other CPU might be
	 * calling kmalloc(GFP_ATOMIC | __GFP_NOWARN) with port->lock held.
	 */
	printk_deferred_enter();

#ifdef CONFIG_NUMA
	memset(node_load, 0, sizeof(node_load));
#endif

	/*
	 * This node is hotadded and no memory is yet present.   So just
	 * building zonelists is fine - no need to touch other nodes.
	 */
	if (self && !node_online(self->node_id)) {
		build_zonelists(self);
	} else {
		/*
		 * All possible nodes have pgdat preallocated
		 * in free_area_init
		 */
		for_each_node(nid) {
			pg_data_t *pgdat = NODE_DATA(nid);

			build_zonelists(pgdat);
		}

#ifdef CONFIG_HAVE_MEMORYLESS_NODES
		/*
		 * We now know the "local memory node" for each node--
		 * i.e., the node of the first zone in the generic zonelist.
		 * Set up numa_mem percpu variable for on-line cpus.  During
		 * boot, only the boot cpu should be on-line;  we'll init the
		 * secondary cpus' numa_mem as they come on-line.  During
		 * node/memory hotplug, we'll fixup all on-line cpus.
		 */
		for_each_online_cpu(cpu)
			set_cpu_numa_mem(cpu, local_memory_node(cpu_to_node(cpu)));
#endif
	}

	printk_deferred_exit();
	write_sequnlock_irqrestore(&zonelist_update_seq, flags);
}
```

for_each_online_nodeéå†äº†ç³»ç»Ÿä¸­æ‰€æœ‰çš„æ´»åŠ¨ç»“ç‚¹ã€‚ç”±äºUMAç³»ç»Ÿåªæœ‰ä¸€ä¸ªç»“ç‚¹ï¼Œbuild_

zonelistsåªè°ƒç”¨äº†ä¸€æ¬¡ï¼Œå°±å¯¹æ‰€æœ‰çš„å†…å­˜åˆ›å»ºäº†å†…å­˜åŸŸåˆ—è¡¨ã€‚NUMAç³»ç»Ÿè°ƒç”¨è¯¥å‡½æ•°çš„æ¬¡æ•°ç­‰åŒäº

ç»“ç‚¹çš„æ•°ç›®ã€‚æ¯æ¬¡è°ƒç”¨å¯¹ä¸€ä¸ªä¸åŒç»“ç‚¹ç”Ÿæˆå†…å­˜åŸŸæ•°æ®ã€‚

build_zonelistséœ€è¦ä¸€ä¸ªæŒ‡å‘pgdata_tå®ä¾‹çš„æŒ‡é’ˆä½œä¸ºå‚æ•°ï¼Œå…¶ä¸­åŒ…å«äº†ç»“ç‚¹å†…å­˜é…ç½®çš„æ‰€

æœ‰ç°å­˜ä¿¡æ¯ï¼Œè€Œæ–°å»ºçš„æ•°æ®ç»“æ„ä¹Ÿä¼šæ”¾ç½®åœ¨å…¶ä¸­ã€‚

åœ¨UMAç³»ç»Ÿä¸Šï¼ŒNODE_DATAè¿”å›contig_page_dataçš„åœ°å€ã€‚

è¯¥å‡½æ•°çš„ä»»åŠ¡æ˜¯ï¼Œåœ¨å½“å‰å¤„ç†çš„ç»“ç‚¹å’Œç³»ç»Ÿä¸­å…¶ä»–ç»“ç‚¹çš„å†…å­˜åŸŸä¹‹é—´å»ºç«‹ä¸€ç§ç­‰çº§æ¬¡åºã€‚æ¥ä¸‹æ¥ï¼Œ

ä¾æ®è¿™ç§æ¬¡åºåˆ†é…å†…å­˜ã€‚å¦‚æœåœ¨æœŸæœ›çš„ç»“ç‚¹å†…å­˜åŸŸä¸­ï¼Œæ²¡æœ‰ç©ºé—²å†…å­˜ï¼Œé‚£ä¹ˆè¿™ç§æ¬¡åºå°±å¾ˆé‡è¦ã€‚

æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªä¾‹å­ï¼Œå…¶ä¸­å†…æ ¸æƒ³è¦åˆ†é…é«˜ç«¯å†…å­˜ã€‚å®ƒé¦–å…ˆä¼å›¾åœ¨å½“å‰ç»“ç‚¹çš„é«˜ç«¯å†…å­˜åŸŸæ‰¾åˆ°ä¸€ä¸ª

å¤§å°é€‚å½“çš„ç©ºé—²æ®µã€‚å¦‚æœå¤±è´¥ï¼Œåˆ™æŸ¥çœ‹è¯¥ç»“ç‚¹çš„æ™®é€šå†…å­˜åŸŸã€‚å¦‚æœè¿˜å¤±è´¥ï¼Œåˆ™è¯•å›¾åœ¨è¯¥ç»“ç‚¹çš„DMA

å†…å­˜åŸŸæ‰§è¡Œåˆ†é…ã€‚å¦‚æœåœ¨3ä¸ªæœ¬åœ°å†…å­˜åŸŸéƒ½æ— æ³•æ‰¾åˆ°ç©ºé—²å†…å­˜ï¼Œåˆ™æŸ¥çœ‹å…¶ä»–ç»“ç‚¹ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¤‡

é€‰ç»“ç‚¹åº”è¯¥å°½å¯èƒ½é è¿‘ä¸»ç»“ç‚¹ï¼Œä»¥æœ€å°åŒ–ç”±äºè®¿é—®éæœ¬åœ°å†…å­˜å¼•èµ·çš„æ€§èƒ½æŸå¤±ã€‚

å†…æ ¸å®šä¹‰äº†å†…å­˜çš„ä¸€ä¸ªå±‚æ¬¡ç»“æ„ï¼Œé¦–å…ˆè¯•å›¾åˆ†é…â€œå»‰ä»·çš„â€å†…å­˜ã€‚å¦‚æœå¤±è´¥ï¼Œåˆ™æ ¹æ®è®¿é—®é€Ÿåº¦å’Œ

å®¹é‡ï¼Œé€æ¸å°è¯•åˆ†é…â€œæ›´æ˜‚è´µçš„â€å†…å­˜ã€‚

é«˜ç«¯å†…å­˜æ˜¯æœ€å»‰ä»·çš„ï¼Œå› ä¸ºå†…æ ¸æ²¡æœ‰ä»»ä½•éƒ¨ä»½ä¾èµ–äºä»è¯¥å†…å­˜åŸŸåˆ†é…çš„å†…å­˜ã€‚å¦‚æœé«˜ç«¯å†…å­˜åŸŸç”¨

å°½ï¼Œå¯¹å†…æ ¸æ²¡æœ‰ä»»ä½•å‰¯ä½œç”¨ï¼Œè¿™ä¹Ÿæ˜¯ä¼˜å…ˆåˆ†é…é«˜ç«¯å†…å­˜çš„åŸå› ã€‚

æ™®é€šå†…å­˜åŸŸçš„æƒ…å†µæœ‰æ‰€ä¸åŒã€‚è®¸å¤šå†…æ ¸æ•°æ®ç»“æ„å¿…é¡»ä¿å­˜åœ¨è¯¥å†…å­˜åŸŸï¼Œè€Œä¸èƒ½æ”¾ç½®åˆ°é«˜ç«¯å†…å­˜åŸŸã€‚

å› æ­¤å¦‚æœæ™®é€šå†…å­˜å®Œå…¨ç”¨å°½ï¼Œé‚£ä¹ˆå†…æ ¸ä¼šé¢ä¸´ç´§æ€¥æƒ…å†µã€‚æ‰€ä»¥åªè¦é«˜ç«¯å†…å­˜åŸŸçš„å†…å­˜æ²¡æœ‰ç”¨å°½ï¼Œéƒ½ä¸

ä¼šä»æ™®é€šå†…å­˜åŸŸåˆ†é…å†…å­˜ã€‚

æœ€æ˜‚è´µçš„æ˜¯DMAå†…å­˜åŸŸï¼Œå› ä¸ºå®ƒç”¨äºå¤–è®¾å’Œç³»ç»Ÿä¹‹é—´çš„æ•°æ®ä¼ è¾“ã€‚å› æ­¤ä»è¯¥å†…å­˜åŸŸåˆ†é…å†…å­˜æ˜¯

æœ€åä¸€æ‹›ã€‚

å†…æ ¸è¿˜é’ˆå¯¹å½“å‰å†…å­˜ç»“ç‚¹çš„å¤‡é€‰ç»“ç‚¹ï¼Œå®šä¹‰äº†ä¸€ä¸ªç­‰çº§æ¬¡åºã€‚è¿™æœ‰åŠ©äºåœ¨å½“å‰ç»“ç‚¹æ‰€æœ‰å†…å­˜åŸŸçš„ 

å†…å­˜éƒ½ç”¨å°½æ—¶ï¼Œç¡®å®šä¸€ä¸ªå¤‡é€‰ç»“ç‚¹ã€‚

å†…æ ¸ä½¿ç”¨pg_data_tä¸­çš„zonelistæ•°ç»„ï¼Œæ¥è¡¨ç¤ºæ‰€æè¿°çš„å±‚æ¬¡ç»“æ„ã€‚

<mmzone.h>

typedef struct pglist_data {

...

struct zonelist node_zonelists[MAX_ZONELISTS];

...

} pg_data_t;

\#define MAX_ZONES_PER_ZONELIST (MAX_NUMNODES * MAX_NR_ZONES)

struct zonelist {

...

struct zone *zones[MAX_ZONES_PER_ZONELIST + 1]; // NULLåˆ†éš”

};

node_zonelistsæ•°ç»„å¯¹æ¯ç§å¯èƒ½çš„å†…å­˜åŸŸç±»å‹ï¼Œéƒ½é…ç½®äº†ä¸€ä¸ªç‹¬ç«‹çš„æ•°ç»„é¡¹ã€‚æ•°ç»„é¡¹åŒ…å«äº†ç±»

å‹ä¸ºzonelistçš„ä¸€ä¸ªå¤‡ç”¨åˆ—è¡¨ï¼Œå…¶ç»“æ„åœ¨ä¸‹é¢è®¨è®ºã€‚

ç”±äºè¯¥å¤‡ç”¨åˆ—è¡¨å¿…é¡»åŒ…æ‹¬æ‰€æœ‰ç»“ç‚¹çš„æ‰€æœ‰å†…å­˜åŸŸï¼Œå› æ­¤ç”±MAX_NUMNODES * MAX_NZ_ZONESé¡¹ç»„

æˆï¼Œå¤–åŠ ä¸€ä¸ªç”¨äºæ ‡è®°åˆ—è¡¨ç»“æŸçš„ç©ºæŒ‡é’ˆã€‚

å»ºç«‹å¤‡ç”¨å±‚æ¬¡ç»“æ„çš„ä»»åŠ¡å§”æ‰˜ç»™build_zonelistsï¼Œè¯¥å‡½æ•°ä¸ºæ¯ä¸ªNUMAç»“ç‚¹éƒ½åˆ›å»ºäº†ç›¸åº”çš„æ•°

æ®ç»“æ„ã€‚å®ƒéœ€è¦æŒ‡å‘ç›¸å…³çš„pg_data_tå®ä¾‹çš„æŒ‡é’ˆä½œä¸ºå‚æ•°ã€‚åœ¨æˆ‘è¯¦ç»†è®¨è®ºä»£ç ä¹‹å‰ï¼Œå…ˆå›æƒ³ä¸€ä¸‹ä¸Š

æ–‡æåˆ°çš„ä¸€ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬å·²ç»å°†è®¨è®ºçš„èŒƒå›´é™åˆ¶åˆ°UMAç³»ç»Ÿï¼Œä¸ºä»€ä¹ˆå¿…é¡»è€ƒè™‘å¤šä¸ªNUMAç»“ç‚¹å‘¢ï¼Ÿ

å®é™…ä¸Šï¼Œå¦‚æœè®¾ç½®äº†CONFIG_NUMAï¼Œå†…æ ¸ä¼šä½¿ç”¨ä¸åŒçš„å®ç°æ›¿æ¢ä¸‹åˆ—ä»£ç ã€‚ä½†ä¹Ÿæœ‰å¯èƒ½æŸä¸ªä½“ç³»ç»“æ„

åœ¨UMAç³»ç»Ÿä¸Šé€‰æ‹©ä¸è¿ç»­æˆ–ç¨€ç–å†…å­˜é€‰é¡¹ã€‚åœ¨åœ°å€ç©ºé—´åŒ…å«è¾ƒå¤§ç©ºæ´çš„æƒ…å†µä¸‹ï¼Œè¿™æ ·åšå¯èƒ½æ˜¯æœ‰å¥½å¤„

çš„ã€‚è¿™æ ·çš„æ´é€ æˆçš„å†…å­˜â€œå—â€ï¼Œæœ€å¥½é€šè¿‡NUMAæä¾›çš„æ•°æ®ç»“æ„æ¥å¤„ç†ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæ­¤å¤„éœ€è¦å¤„

ç†NUMAç»“ç‚¹çš„åŸå› ã€‚

ä¸€ä¸ªå¤§çš„å¤–éƒ¨å¾ªç¯é¦–å…ˆè¿­ä»£æ‰€æœ‰çš„ç»“ç‚¹å†…å­˜åŸŸã€‚æ¯ä¸ªå¾ªç¯åœ¨zonelistæ•°ç»„ä¸­æ‰¾åˆ°ç¬¬iä¸ªzonelistï¼Œ

å¯¹ç¬¬iä¸ªå†…å­˜åŸŸè®¡ç®—å¤‡ç”¨åˆ—è¡¨ã€‚

mm/page_alloc.c

static void __init build_zonelists(pg_data_t *pgdat)

{

int node, local_node;

enum zone_type i,j;

local_node = pgdat->node_id;

for (i = 0; i < MAX_NR_ZONES; i++) {

struct zonelist *zonelist;

zonelist = pgdat->node_zonelists + i;

j = build_zonelists_node(pgdat, zonelist, 0, i);

...

}

node_zonelistsçš„æ•°ç»„å…ƒç´ é€šè¿‡æŒ‡é’ˆæ“ä½œå¯»å€ï¼Œè¿™åœ¨Cè¯­è¨€ä¸­æ˜¯å®Œå…¨åˆæ³•çš„æƒ¯ä¾‹ã€‚å®é™…å·¥ä½œåˆ™å§”

æ‰˜ç»™build_zonelist_nodeã€‚åœ¨è°ƒç”¨æ—¶ï¼Œå®ƒé¦–å…ˆç”Ÿæˆæœ¬åœ°ç»“ç‚¹å†…åˆ†é…å†…å­˜æ—¶çš„å¤‡ç”¨æ¬¡åºã€‚

mm/page_alloc.c

static int __init build_zonelists_node(pg_data_t *pgdat, struct zonelist *zonelist,

int nr_zones, enum zone_type zone_type)

{

struct zone *zone;

1

2

3

4

5

6

7

8

9

10134 ç¬¬ 3 ç«  å†… å­˜ ç®¡ ç†

do {

zone = pgdat->node_zones + zone_type;

if (populated_zone(zone)) {

zonelist->zones[nr_zones++] = zone;

}

zone_type--;

} while (zone_type >= 0);

return nr_zones;

}

å¤‡ç”¨åˆ—è¡¨çš„å„é¡¹æ˜¯å€ŸåŠ©äºzone_typeå‚æ•°æ’åºçš„ï¼Œè¯¥å‚æ•°æŒ‡å®šäº†æœ€ä¼˜å…ˆé€‰æ‹©å“ªä¸ªå†…å­˜åŸŸï¼Œè¯¥å‚æ•°

çš„åˆå§‹å€¼æ˜¯å¤–å±‚å¾ªç¯çš„æ§åˆ¶å˜é‡iã€‚æˆ‘ä»¬çŸ¥é“å…¶å€¼å¯èƒ½æ˜¯ZONE_HIGHMEMã€ZONE_NORMALã€ZONE_DMA

æˆ–ZONE_DMA32ä¹‹ä¸€ã€‚nr_zonesè¡¨ç¤ºä»å¤‡ç”¨åˆ—è¡¨ä¸­çš„å“ªä¸ªä½ç½®å¼€å§‹å¡«å……æ–°é¡¹ã€‚ç”±äºåˆ—è¡¨ä¸­å°šæ²¡æœ‰é¡¹ï¼Œ

å› æ­¤è°ƒç”¨è€…ä¼ é€’äº†0ã€‚

å†…æ ¸åœ¨build_zonelistsä¸­æŒ‰åˆ†é…ä»£ä»·ä»æ˜‚è´µåˆ°ä½å»‰çš„æ¬¡åºï¼Œè¿­ä»£äº†ç»“ç‚¹ä¸­æ‰€æœ‰çš„å†…å­˜åŸŸã€‚è€Œåœ¨

build_zonelists_nodeä¸­ï¼Œåˆ™æŒ‰ç…§åˆ†é…ä»£ä»·ä»ä½å»‰åˆ°æ˜‚è´µçš„æ¬¡åºï¼Œè¿­ä»£äº†åˆ†é…ä»£ä»·ä¸ä½äºå½“å‰å†…å­˜

åŸŸçš„å†…å­˜åŸŸã€‚åœ¨build_zonelists_nodeçš„æ¯ä¸€æ­¥ä¸­ï¼Œéƒ½å¯¹æ‰€é€‰çš„å†…å­˜åŸŸè°ƒç”¨populated_zoneï¼Œç¡®è®¤

zone->present_pageså¤§äº0ï¼Œå³ç¡®è®¤å†…å­˜åŸŸä¸­ç¡®å®æœ‰é¡µå­˜åœ¨ã€‚å€˜è‹¥å¦‚æ­¤ï¼Œåˆ™å°†æŒ‡å‘zoneå®ä¾‹çš„æŒ‡é’ˆ

æ·»åŠ åˆ°zonelist->zonesä¸­çš„å½“å‰ä½ç½®ã€‚åå¤‡åˆ—è¡¨çš„å½“å‰ä½ç½®ä¿å­˜åœ¨nr_zonesã€‚

åœ¨æ¯ä¸€æ­¥ç»“æŸæ—¶ï¼Œéƒ½å°†å†…å­˜åŸŸç±»å‹å‡1ã€‚æ¢å¥è¯è¯´ï¼Œè®¾ç½®ä¸ºä¸€ä¸ªæ›´æ˜‚è´µçš„å†…å­˜åŸŸç±»å‹ã€‚ä¾‹å¦‚ï¼Œå¦‚

æœå¼€å§‹çš„å†…å­˜åŸŸæ˜¯ZONE_HIGHMEMï¼Œå‡1åä¸‹ä¸€ä¸ªå†…å­˜åŸŸç±»å‹æ˜¯ZONE_NORMALã€‚

è€ƒè™‘ä¸€ä¸ªç³»ç»Ÿï¼Œæœ‰å†…å­˜åŸŸZONE_HIGHMEMã€ZONE_NORMALã€ZONE_DMAã€‚åœ¨ç¬¬ä¸€æ¬¡è¿è¡Œbuild_

zonelists_nodeæ—¶ï¼Œå®é™…ä¸Šä¼šæ‰§è¡Œä¸‹åˆ—èµ‹å€¼ï¼š

zonelist->zones[0] = ZONE_HIGHMEM;

zonelist->zones[1] = ZONE_NORMAL;

zonelist->zones[2] = ZONE_DMA;

å›¾3-9ä»¥æŸä¸ªç³»ç»Ÿçš„ç»“ç‚¹2ä¸ºä¾‹è¯´æ˜äº†è¿™ä¸€ç‚¹ï¼Œå›¾ä¸­ç¤ºèŒƒäº†ä¸€ä¸ªå¤‡ç”¨åˆ—è¡¨åœ¨å¤šæ¬¡å¾ªç¯ä¸­ä¸æ–­å¡«å……çš„

è¿‡ç¨‹ã€‚ç³»ç»Ÿä¸­æ€»å…±æœ‰4ä¸ªç»“ç‚¹ï¼ˆnumnodes = 4ï¼‰ã€‚

A=ï¼ˆNUMAï¼‰ç»“ç‚¹0 0=DMAå†…å­˜åŸŸ

B=ï¼ˆNUMAï¼‰ç»“ç‚¹1 1=æ™®é€šå†…å­˜åŸŸ

C=ï¼ˆNUMAï¼‰ç»“ç‚¹2 2=é«˜ç«¯å†…å­˜åŸŸ

D=ï¼ˆNUMAï¼‰ç»“ç‚¹3

å›¾3-9 è¿ç»­å¡«å……å¤‡ç”¨åˆ—è¡¨

ç¬¬ä¸€æ­¥ä¹‹åï¼Œåˆ—è¡¨ä¸­çš„åˆ†é…ç›®æ ‡æ˜¯é«˜ç«¯å†…å­˜ï¼Œæ¥ä¸‹æ¥æ˜¯ç¬¬äºŒä¸ªç»“ç‚¹çš„æ™®é€šå’ŒDMAå†…å­˜åŸŸã€‚

å†…æ ¸æ¥ä¸‹æ¥å¿…é¡»ç¡®ç«‹æ¬¡åºï¼Œä»¥ä¾¿å°†ç³»ç»Ÿä¸­å…¶ä»–ç»“ç‚¹çš„å†…å­˜åŸŸæŒ‰ç…§æ¬¡åºåŠ å…¥åˆ°å¤‡ç”¨åˆ—è¡¨ã€‚

mm/page_alloc.c

static void __init build_zonelists(pg_data_t *pgdat)

{

...

for (node = local_node + 1; node < MAX_NUMNODES; node++) {

j = build_zonelists_node(NODE_DATA(node), zonelist, j, i);

}

for (node = 0; node < local_node; node++) {3.4 åˆå§‹åŒ–å†…å­˜ç®¡ç† 135

j = build_zonelists_node(NODE_DATA(node), zonelist, j, i);

}

zonelist->zones[j] = NULL;

}

}

}

ç¬¬ä¸€ä¸ªå¾ªç¯ä¾æ¬¡è¿­ä»£å¤§äºå½“å‰ç»“ç‚¹ç¼–å·çš„æ‰€æœ‰ç»“ç‚¹ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œæœ‰4ä¸ªç»“ç‚¹ç¼–å·å‰¯æœ¬ä¸º0ã€

1ã€2ã€3ï¼Œæ­¤æ—¶åªå‰©ä¸‹ç»“ç‚¹3ã€‚æ–°çš„é¡¹é€šè¿‡build_zonelists_nodeè¢«åŠ åˆ°å¤‡ç”¨åˆ—è¡¨ã€‚æ­¤æ—¶jçš„ä½œç”¨å°±ä½“

ç°å‡ºæ¥äº†ã€‚åœ¨æœ¬åœ°ç»“ç‚¹çš„å¤‡ç”¨ç›®æ ‡æ‰¾åˆ°ä¹‹åï¼Œè¯¥å˜é‡çš„å€¼æ˜¯3ã€‚è¯¥å€¼ç”¨ä½œæ–°é¡¹çš„èµ·å§‹ä½ç½®ã€‚å¦‚æœç»“ç‚¹3

ä¹Ÿç”±3ä¸ªå†…å­˜åŸŸç»„æˆï¼Œå¤‡ç”¨åˆ—è¡¨åœ¨ç¬¬äºŒä¸ªå¾ªç¯ä¹‹åçš„æƒ…å†µå¦‚å›¾3-9çš„ç¬¬äºŒæ­¥æ‰€ç¤ºã€‚

ç¬¬äºŒä¸ªforå¾ªç¯æ¥ä¸‹æ¥å¯¹æ‰€æœ‰ç¼–å·å°äºå½“å‰ç»“ç‚¹çš„ç»“ç‚¹ç”Ÿæˆå¤‡ç”¨åˆ—è¡¨é¡¹ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè¿™äº›

ç»“ç‚¹çš„ç¼–å·ä¸º0å’Œ1ã€‚ å¦‚æœè¿™äº›ç»“ç‚¹ä¹Ÿæœ‰3ä¸ªå†…å­˜åŸŸï¼Œåˆ™å¾ªç¯å®Œæ¯•ä¹‹åå¤‡ç”¨åˆ—è¡¨çš„æƒ…å†µå¦‚å›¾3-9ä¸‹åŠéƒ¨åˆ†

æ‰€ç¤ºã€‚

å¤‡ç”¨åˆ—è¡¨ä¸­é¡¹çš„æ•°ç›®ä¸€èˆ¬æ— æ³•å‡†ç¡®çŸ¥é“ï¼Œå› ä¸ºç³»ç»Ÿä¸­ä¸åŒç»“ç‚¹çš„å†…å­˜åŸŸé…ç½®å¯èƒ½å¹¶ä¸ç›¸åŒã€‚å› æ­¤

åˆ—è¡¨çš„æœ€åä¸€é¡¹èµ‹å€¼ä¸ºç©ºæŒ‡é’ˆï¼Œæ˜¾å¼æ ‡è®°åˆ—è¡¨ç»“æŸã€‚

å¯¹æ€»æ•°Nä¸ªç»“ç‚¹ä¸­çš„ç»“ç‚¹mæ¥è¯´ï¼Œå†…æ ¸ç”Ÿæˆå¤‡ç”¨åˆ—è¡¨æ—¶ï¼Œé€‰æ‹©å¤‡ç”¨ç»“ç‚¹çš„é¡ºåºæ€»æ˜¯ï¼šmã€m+1ã€

m+2ã€â€¦ã€Nï€­1ã€0ã€1ã€â€¦ã€mï€­1ã€‚è¿™ç¡®ä¿äº†ä¸è¿‡åº¦ä½¿ç”¨ä»»ä½•ç»“ç‚¹ã€‚ä¾‹å¦‚ï¼Œå¯¹ç…§æƒ…å†µæ˜¯ï¼šä½¿ç”¨ä¸€ä¸ªç‹¬ç«‹

äºmã€ä¸å˜çš„å¤‡ç”¨åˆ—è¡¨ã€‚

å›¾3-10ç»™å‡ºäº†æœ‰4ä¸ªç»“ç‚¹çš„ç³»ç»Ÿä¸­ä¸ºç¬¬ä¸‰ç»“ç‚¹å»ºç«‹çš„å¤‡ç”¨åˆ—è¡¨ã€‚

æ™®é€šå†…å­˜åŸŸ

é«˜ç«¯å†…å­˜åŸŸ

DMAå†…å­˜åŸŸ

å›¾3-10 å®Œæˆçš„å¤‡ç”¨åˆ—è¡¨

3.5.5èŠ‚è®¨è®ºäº†å¦‚ä½•åˆ©ç”¨æ­¤å¤„ç”Ÿæˆçš„å¤‡ç”¨åˆ—è¡¨å®ç°ä¼™ä¼´ç³»ç»Ÿã€‚



###### 3.4.2 ç‰¹å®šäºä½“ç³»ç»“æ„çš„è®¾ç½®

åœ¨ IA-32 ç³»ç»Ÿä¸Šï¼Œå†…å­˜ç®¡ç†çš„åˆå§‹åŒ–åœ¨æŸäº›æ–¹é¢æ˜¾å¾—æ ¼å¤–å¾®å¦™ï¼Œéœ€è¦å…‹æœä¸€äº›æºäºå¤„ç†å™¨æ¶æ„å†å²çš„éšœç¢ã€‚ä¾‹å¦‚ï¼Œå¿…é¡»å°†å¤„ç†å™¨ä»å®æ¨¡å¼åˆ‡æ¢åˆ°ä¿æŠ¤æ¨¡å¼ï¼Œå¹¶æ˜¾å¼æˆäºˆ CPU è®¿é—® 32 ä½åœ°å€ç©ºé—´çš„æƒé™â€”â€”è¿™äº›æ­¥éª¤éƒ½æ˜¯ä¸ºäº†å…¼å®¹æ—©æœŸçš„ 16 ä½ 8086 å¤„ç†å™¨è€Œä¿ç•™ä¸‹æ¥çš„é—äº§ã€‚åŒæ ·ï¼Œåˆ†é¡µæœºåˆ¶åœ¨é»˜è®¤æƒ…å†µä¸‹æ˜¯å…³é—­çš„ï¼Œå¿…é¡»é€šè¿‡æ“ä½œ CR0 å¯„å­˜å™¨æ‰‹åŠ¨å¯ç”¨ã€‚



è™½ç„¶ç”¨æ¥åˆ’å®šæ®µè¾¹ç•Œçš„å˜é‡å®šä¹‰åœ¨å†…æ ¸æºä»£ç ï¼ˆarch/x86/kernel/setup_32.cï¼‰ä¸­ï¼Œ

ä½†æ­¤æ—¶å°šæœªèµ‹å€¼ã€‚è¿™æ˜¯å› ä¸ºä¸å¤ªå¯èƒ½ã€‚ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶é—´æ€ä¹ˆèƒ½çŸ¥é“å†…æ ¸æœ€ç»ˆæœ‰å¤šå¤§ï¼Ÿåªæœ‰

åœ¨ç›®æ ‡æ–‡ä»¶é“¾æ¥å®Œæˆåï¼Œæ‰èƒ½çŸ¥é“ç¡®åˆ‡çš„æ•°å€¼ï¼Œæ¥ä¸‹æ¥åˆ™æ‰“åŒ…ä¸ºäºŒè¿›åˆ¶æ–‡ä»¶ã€‚è¯¥æ“ä½œæ˜¯ç”±

arch/arch/vmlinux.ld.Sæ§åˆ¶çš„ï¼ˆå¯¹IA-32æ¥è¯´ï¼Œè¯¥æ–‡ä»¶æ˜¯arch/x86/vmlinux_32.ld.Sï¼‰ï¼Œ

å…¶ä¸­ä¹Ÿåˆ’å®šäº†å†…æ ¸çš„å†…å­˜å¸ƒå±€ã€‚

2.   åˆå§‹åŒ–æ­¥éª¤

åœ¨å†…æ ¸å·²ç»è½½å…¥å†…å­˜ã€è€Œåˆå§‹åŒ–çš„æ±‡ç¼–ç¨‹åºéƒ¨åˆ†å·²ç»æ‰§è¡Œå®Œæ¯•åï¼Œå†…æ ¸å¿…é¡»æ‰§è¡Œå“ªäº›ç‰¹å®šäºç³»ç»Ÿ

çš„æ­¥éª¤ï¼Ÿ



3.   åˆ†é¡µæœºåˆ¶çš„åˆå§‹åŒ–

paging_initè´Ÿè´£å»ºç«‹åªèƒ½ç”¨äºå†…æ ¸çš„é¡µè¡¨ï¼Œç”¨æˆ·ç©ºé—´æ— æ³•è®¿é—®ã€‚è¿™å¯¹ç®¡ç†æ™®é€šåº”ç”¨ç¨‹åºå’Œå†…æ ¸

è®¿é—®å†…å­˜çš„æ–¹å¼ï¼Œæœ‰æ·±è¿œçš„å½±å“ã€‚å› æ­¤åœ¨ä»”ç»†è€ƒå¯Ÿå…¶å®ç°ä¹‹å‰ï¼Œå¾ˆé‡è¦çš„ä¸€ç‚¹æ˜¯è§£é‡Šè¯¥å‡½æ•°çš„ç›®çš„ã€‚

ç¬¬1ç« æåˆ°ï¼Œåœ¨IA-32ç³»ç»Ÿä¸Šå†…æ ¸é€šå¸¸å°†æ€»çš„4 GiBå¯ç”¨è™šæ‹Ÿåœ°å€ç©ºé—´æŒ‰3 : 1çš„æ¯”ä¾‹åˆ’åˆ†ã€‚ä½ç«¯3 GiB

ç”¨äºç”¨æˆ·çŠ¶æ€åº”ç”¨ç¨‹åºï¼Œè€Œé«˜ç«¯çš„1 GiBåˆ™ä¸“ç”¨äºå†…æ ¸ã€‚å°½ç®¡åœ¨åˆ†é…å†…æ ¸çš„è™šæ‹Ÿåœ°å€ç©ºé—´æ—¶ï¼Œå½“å‰ç³»ç»Ÿ

ä¸Šä¸‹æ–‡æ˜¯ä¸ç›¸å¹²çš„ï¼Œä½†æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰è‡ªèº«ç‰¹å®šçš„åœ°å€ç©ºé—´ã€‚

è¿™äº›åˆ’åˆ†ä¸»è¦çš„åŠ¨æœºå¦‚ä¸‹æ‰€ç¤ºã€‚

ï± åœ¨ç”¨æˆ·åº”ç”¨ç¨‹åºçš„æ‰§è¡Œåˆ‡æ¢åˆ°æ ¸å¿ƒæ€æ—¶ï¼ˆè¿™æ€»æ˜¯ä¼šå‘ç”Ÿï¼Œä¾‹å¦‚åœ¨ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨æˆ–å‘ç”Ÿå‘¨æœŸæ€§

çš„æ—¶é’Ÿä¸­æ–­æ—¶ï¼‰ï¼Œå†…æ ¸å¿…é¡»è£…è½½åœ¨ä¸€ä¸ªå¯é çš„ç¯å¢ƒä¸­ã€‚å› æ­¤æœ‰å¿…è¦å°†åœ°å€ç©ºé—´çš„ä¸€éƒ¨åˆ†åˆ†é…

ç»™å†…æ ¸ä¸“ç”¨ã€‚

ï± ç‰©ç†å†…å­˜é¡µåˆ™æ˜ å°„åˆ°å†…æ ¸åœ°å€ç©ºé—´çš„èµ·å§‹å¤„ï¼Œä»¥ä¾¿å†…æ ¸ç›´æ¥è®¿é—®ï¼Œè€Œæ— éœ€å¤æ‚çš„é¡µè¡¨æ“ä½œã€‚



##### 3.5 ç‰©ç†å†…å­˜çš„ç®¡ç†

é˜¶æ˜¯ä¼™ä¼´ç³»ç»Ÿä¸­ä¸€ä¸ªéå¸¸é‡è¦çš„æœ¯è¯­ã€‚å®ƒæè¿°äº†å†…å­˜åˆ†é…çš„æ•°é‡å•ä½ã€‚å†…å­˜å—çš„é•¿åº¦æ˜¯2orderï¼Œå…¶

ä¸­orderçš„èŒƒå›´ä»0åˆ°MAX_ORDERã€‚

<mmzone.h>

\#ifndef CONFIG_FORCE_MAX_ZONEORDER

\#define MAX_ORDER 11

\#else

\#define MAX_ORDER CONFIG_FORCE_MAX_ZONEORDER

\#endif

\#define MAX_ORDER_NR_PAGES (1 << (MAX_ORDER -1))

è¯¥å¸¸æ•°é€šå¸¸è®¾ç½®ä¸º11ï¼Œè¿™æ„å‘³ç€ä¸€æ¬¡åˆ†é…å¯ä»¥è¯·æ±‚çš„é¡µæ•°æœ€å¤§æ˜¯211=2 048ã€‚ä½†å¦‚æœç‰¹å®šäºä½“ç³»ç»“

æ„çš„ä»£ç è®¾ç½®äº†FORCE_MAX_ZONEORDERé…ç½®é€‰é¡¹ï¼Œè¯¥å€¼ä¹Ÿå¯ä»¥æ‰‹å·¥æ”¹å˜ã€‚ä¾‹å¦‚ï¼ŒIA-64ç³»ç»Ÿä¸Šå·¨å¤§çš„

åœ°å€ç©ºé—´å¯ä»¥å¤„ç†MAX_ORDER = 18çš„æƒ…å½¢ï¼Œè€ŒARMæˆ–v850ç³»ç»Ÿåˆ™ä½¿ç”¨æ›´å°çš„å€¼ï¼ˆå¦‚8æˆ–9ï¼‰ ã€‚ä½†è¿™ä¸ä¸€

å®šæ˜¯ç”±è®¡ç®—æœºæ”¯æŒçš„å†…å­˜æ•°é‡æ¯”è¾ƒå°å¼•èµ·çš„ï¼Œä¹Ÿå¯èƒ½æ˜¯å†…å­˜å¯¹é½æ–¹å¼çš„è¦æ±‚æ‰€å¯¼è‡´ã€‚æˆ–è€…å¯ä»¥å‚è€ƒ

v850ä½“ç³»ç»“æ„çš„Kconfigé…ç½®æ–‡ä»¶çš„æè¿°ï¼š



ä¼™ä¼´ä¸å¿…æ˜¯å½¼æ­¤è¿æ¥çš„ã€‚å¦‚æœä¸€ä¸ªå†…å­˜åŒºåœ¨åˆ†é…å…¶é—´åˆ†è§£ä¸ºä¸¤åŠï¼Œå†…æ ¸ä¼šè‡ªåŠ¨å°†æœªç”¨çš„ä¸€åŠåŠ å…¥

åˆ°å¯¹åº”çš„é“¾è¡¨ä¸­ã€‚å¦‚æœåœ¨æœªæ¥çš„æŸä¸ªæ—¶åˆ»ï¼Œç”±äºå†…å­˜é‡Šæ”¾çš„ç¼˜æ•…ï¼Œä¸¤ä¸ªå†…å­˜åŒºéƒ½å¤„äºç©ºé—²çŠ¶æ€ï¼Œå¯é€š

è¿‡å…¶åœ°å€åˆ¤æ–­å…¶æ˜¯å¦ä¸ºä¼™ä¼´ã€‚ç®¡ç†å·¥ä½œè¾ƒå°‘ï¼Œæ˜¯ä¼™ä¼´ç³»ç»Ÿçš„ä¸€ä¸ªä¸»è¦ä¼˜ç‚¹ã€‚

åŸºäºä¼™ä¼´ç³»ç»Ÿçš„å†…å­˜ç®¡ç†ä¸“æ³¨äºæŸä¸ªç»“ç‚¹çš„æŸä¸ªå†…å­˜åŸŸï¼Œä¾‹å¦‚ï¼ŒDMAæˆ–é«˜ç«¯å†…å­˜åŸŸã€‚ä½†æ‰€æœ‰å†…

å­˜åŸŸå’Œç»“ç‚¹çš„ä¼™ä¼´ç³»ç»Ÿéƒ½é€šè¿‡å¤‡ç”¨åˆ†é…åˆ—è¡¨è¿æ¥èµ·æ¥ã€‚å›¾3-23è¯´æ˜äº†è¿™ç§å…³ç³»ã€‚

åœ¨é¦–é€‰çš„å†…å­˜åŸŸæˆ–èŠ‚ç‚¹æ— æ³•æ»¡è¶³å†…å­˜åˆ†é…è¯·æ±‚æ—¶ï¼Œé¦–å…ˆå°è¯•åŒä¸€ç»“ç‚¹çš„å¦ä¸€ä¸ªå†…å­˜åŸŸï¼Œæ¥ä¸‹æ¥å†

å°è¯•å¦ä¸€ä¸ªç»“ç‚¹ï¼Œç›´è‡³æ»¡è¶³è¯·æ±‚ã€‚





è¿™æ®µè¯è™½ç„¶æœ‰äº›æ‹—å£ï¼Œä½†å®ƒåœ¨è®²è¿° **Linux å†…æ ¸ä¸­ä¼™ä¼´ç³»ç»Ÿï¼ˆbuddy allocatorï¼‰çš„è®¾è®¡å’Œå†…å­˜åˆ†é…ç­–ç•¥**ã€‚ä¸‹é¢æˆ‘å¸®ä½ é€å¥æ‹†è§£å¹¶è§£é‡Šï¼š

------

### ğŸ“Œ åŸæ–‡ä¸€ï¼š

>   **ä¼™ä¼´ä¸å¿…æ˜¯å½¼æ­¤è¿æ¥çš„ã€‚å¦‚æœä¸€ä¸ªå†…å­˜åŒºåœ¨åˆ†é…å…¶é—´åˆ†è§£ä¸ºä¸¤åŠï¼Œå†…æ ¸ä¼šè‡ªåŠ¨å°†æœªç”¨çš„ä¸€åŠåŠ å…¥åˆ°å¯¹åº”çš„é“¾è¡¨ä¸­ã€‚**

#### âœ… ç†è§£ï¼š

-   åœ¨ buddy åˆ†é…å™¨ä¸­ï¼Œä¸€ä¸ªå¤§å—çš„å†…å­˜ï¼ˆä¾‹å¦‚ order 3ï¼‰å¯èƒ½è¢«æ‹†æˆä¸¤ä¸ªè¾ƒå°å—ï¼ˆorder 2ï¼‰ã€‚
-   è¢«ä½¿ç”¨çš„ä¸€åŠä¼šè¿”å›ç»™è°ƒç”¨è€…ï¼Œ**å¦ä¸€åŠï¼ˆç©ºé—²çš„ï¼‰ä¼šè¢«åŠ å…¥ `free_area[2]` é“¾è¡¨**ä¸­ç®¡ç†ã€‚
-   æ‰€è°“â€œä¼™ä¼´â€æ˜¯æŒ‡ä¸¤ä¸ªç›¸é‚»çš„åŒé˜¶å—ï¼Œå®ƒä»¬å¯ä»¥åœ¨æœªæ¥è¢«åˆå¹¶ã€‚

>   âš ï¸ â€œä¸å¿…è¿æ¥â€æ˜¯è¯´ï¼šä¼™ä¼´é¡µå¹¶ä¸ä¸€å®šåœ¨é“¾è¡¨ä¸­ç›´æ¥ç›¸é‚»æˆ–ä»¥æŸç§ç»“æ„ç»‘å®šåœ¨ä¸€èµ·ï¼Œè€Œæ˜¯**æŒ‰éœ€æ‹†åˆ†ã€æŒ‰éœ€ç»„åˆ**ã€‚

------

### ğŸ“Œ åŸæ–‡äºŒï¼š

>   **å¦‚æœåœ¨æœªæ¥çš„æŸä¸ªæ—¶åˆ»ï¼Œç”±äºå†…å­˜é‡Šæ”¾çš„ç¼˜æ•…ï¼Œä¸¤ä¸ªå†…å­˜åŒºéƒ½å¤„äºç©ºé—²çŠ¶æ€ï¼Œå¯é€šè¿‡å…¶åœ°å€åˆ¤æ–­å…¶æ˜¯å¦ä¸ºä¼™ä¼´ã€‚**

#### âœ… ç†è§£ï¼š

-   å†…æ ¸é€šè¿‡é¡µæ¡†ç‰©ç†åœ°å€å¿«é€Ÿåˆ¤æ–­ä¸¤ä¸ªç©ºé—²å—æ˜¯å¦æ˜¯â€œä¼™ä¼´â€ã€‚

-   åˆ¤æ–­æ–¹å¼æ˜¯ï¼š

    ```
    c
    
    
    å¤åˆ¶ç¼–è¾‘
    is_buddy = ((addr_of_block_1 ^ addr_of_block_2) == size_of_block)
    ```

    æˆ–è€…æ¢å¥è¯è¯´ï¼Œä¸¤ä¸ªå—å¿…é¡»ï¼š

    -   è¿ç»­
    -   å¤§å°ç›¸åŒ
    -   åœ°å€å¯¹é½

-   å¦‚æœåˆ¤æ–­ä¸ºä¼™ä¼´ï¼Œå°±å¯ä»¥å°†å®ƒä»¬ä»é“¾è¡¨ä¸­ç§»é™¤ã€åˆå¹¶ä¸ºæ›´å¤§çš„å—ï¼ˆorder+1ï¼‰ã€‚

>   ğŸ“Œ è¿™ä½“ç°äº† buddy çš„é«˜æ•ˆï¼š**æ— éœ€ç»´æŠ¤å¤æ‚ç»“æ„ï¼Œä»…é åœ°å€åˆ¤æ–­æ˜¯å¦åˆå¹¶**ã€‚

------

### ğŸ“Œ åŸæ–‡ä¸‰ï¼š

>   **ç®¡ç†å·¥ä½œè¾ƒå°‘ï¼Œæ˜¯ä¼™ä¼´ç³»ç»Ÿçš„ä¸€ä¸ªä¸»è¦ä¼˜ç‚¹ã€‚**

#### âœ… ç†è§£ï¼š

-   ä¸éœ€è¦å¤æ‚çš„æ ‘ç»“æ„æˆ–æŒ‡é’ˆå…³ç³»ï¼Œä»…éœ€æŒ‰ `order` ç®¡ç†å¤šä¸ªé“¾è¡¨ã€‚
-   ç©ºé—²å—ä¹‹é—´é åœ°å€å…³ç³»åˆ¤æ–­æ˜¯å¦ä¸ºâ€œä¼™ä¼´â€ï¼Œåˆå¹¶æ—¶ä¹Ÿä¸å¤æ‚ã€‚
-   è¿™è®©å®ƒçš„å®ç°ç®€å•ã€åˆ†é…/é‡Šæ”¾é€Ÿåº¦å¿«ï¼Œé€‚åˆå†…æ ¸é¡µæ¡†åˆ†é…å™¨ä½¿ç”¨ã€‚

------

### ğŸ“Œ åŸæ–‡å››ï¼š

>   **åŸºäºä¼™ä¼´ç³»ç»Ÿçš„å†…å­˜ç®¡ç†ä¸“æ³¨äºæŸä¸ªç»“ç‚¹çš„æŸä¸ªå†…å­˜åŸŸï¼Œä¾‹å¦‚ï¼ŒDMAæˆ–é«˜ç«¯å†…å­˜åŸŸã€‚**

#### âœ… ç†è§£ï¼š

-   åœ¨ NUMA æˆ–æ™®é€šç³»ç»Ÿä¸­ï¼Œç‰©ç†å†…å­˜è¢«åˆ†æˆå¤šä¸ª zoneï¼š
    -   `ZONE_DMA`ï¼šç”¨äºç‰¹æ®Šè®¾å¤‡
    -   `ZONE_NORMAL`ï¼šå¸¸è§„å†…å­˜
    -   `ZONE_HIGHMEM`ï¼šx86 32 ä½ä¸Šçš„é«˜ç«¯å†…å­˜ï¼ˆx86-64 æ²¡æœ‰äº†ï¼‰
-   æ¯ä¸ª `zone` éƒ½ç»´æŠ¤è‡ªå·±çš„ `buddy allocator`ï¼ˆå³ `zone->free_area[]`ï¼‰
-   **ä¼™ä¼´ç³»ç»Ÿçš„ä½œç”¨èŒƒå›´å±€é™äºæŸä¸€ä¸ª zone**ã€‚

------

### ğŸ“Œ åŸæ–‡äº”ï¼š

>   **ä½†æ‰€æœ‰å†…å­˜åŸŸå’Œç»“ç‚¹çš„ä¼™ä¼´ç³»ç»Ÿéƒ½é€šè¿‡å¤‡ç”¨åˆ†é…åˆ—è¡¨è¿æ¥èµ·æ¥ã€‚å›¾3-23è¯´æ˜äº†è¿™ç§å…³ç³»ã€‚**

#### âœ… ç†è§£ï¼š

-   å½“æŸä¸ª zone ä¸­åˆ†é…å¤±è´¥ï¼Œæ¯”å¦‚ `ZONE_NORMAL` æ— æ³•æ»¡è¶³éœ€æ±‚ï¼š
    -   å†…æ ¸å¯ä»¥å°è¯• fallback åˆ°ï¼š
        -   è¯¥èŠ‚ç‚¹ï¼ˆnodeï¼‰ä¸­çš„å…¶ä»– zoneï¼ˆå¦‚ `ZONE_HIGHMEM`ï¼‰
        -   æˆ–å…¶ä»–èŠ‚ç‚¹çš„å†…å­˜ï¼ˆåœ¨ NUMA ç³»ç»Ÿä¸­ï¼‰
-   è¿™ç§â€œå¤‡ç”¨åˆ†é…é€»è¾‘â€ç”± `zonelist` ç»“æ„ç®¡ç†ã€‚
-   `zonelist` æ˜¯ä¸€ä¸ª per-node çš„ fallback é“¾è¡¨ï¼šè®°å½•äº†ä¼˜å…ˆå°è¯•çš„ zone é¡ºåºã€‚

------

### ğŸ“Œ åŸæ–‡å…­ï¼š

>   **åœ¨é¦–é€‰çš„å†…å­˜åŸŸæˆ–èŠ‚ç‚¹æ— æ³•æ»¡è¶³å†…å­˜åˆ†é…è¯·æ±‚æ—¶ï¼Œé¦–å…ˆå°è¯•åŒä¸€ç»“ç‚¹çš„å¦ä¸€ä¸ªå†…å­˜åŸŸï¼Œæ¥ä¸‹æ¥å†å°è¯•å¦ä¸€ä¸ªç»“ç‚¹ï¼Œç›´è‡³æ»¡è¶³è¯·æ±‚ã€‚**

#### âœ… ç†è§£ï¼š

-   å†…å­˜åˆ†é…ä¸æ˜¯å…¨å±€æ— åºæŸ¥æ‰¾ï¼Œè€Œæ˜¯æœ‰ä¸€å¥—ä¼˜å…ˆçº§ç­–ç•¥ã€‚
-   ä¸¾ä¸ªä¾‹å­ï¼š
    1.  é¦–å…ˆå°è¯• `local node -> ZONE_NORMAL`
    2.  ç„¶å `local node -> ZONE_HIGHMEM`
    3.  å†å°è¯• `remote node -> ZONE_NORMAL`
-   è¿™ç§é€»è¾‘ç”± `__alloc_pages()` å’Œ `get_page_from_freelist()` å®ç°ã€‚

------

## âœ… æ€»ç»“ä¸€å¥è¯ï¼š

>   Linux çš„ buddy ç³»ç»Ÿé€šè¿‡æ¯ä¸ª zone çš„ `free_area[]` åˆ†çº§ç®¡ç†ç©ºé—²é¡µé¢ï¼Œå—ä¹‹é—´æ— éœ€æ˜¾å¼è¿æ¥ï¼Œæ˜¯å¦ä¸ºä¼™ä¼´é åœ°å€åˆ¤æ–­ï¼Œç»“æ„ç®€å•é«˜æ•ˆã€‚è€Œå®é™…åˆ†é…ç­–ç•¥åˆ™ç”± `zonelist` æ§åˆ¶ï¼Œä»é¦–é€‰ zone å‘å…¶ä»– zone å’Œ node å›é€€ï¼Œç›´åˆ°æ»¡è¶³éœ€æ±‚ã€‚

å¦‚æœä½ è¿˜æœ‰å…³äº `buddy` çš„ä»£ç ç»†èŠ‚ã€æ•°æ®ç»“æ„æˆ–æ€§èƒ½é—®é¢˜ï¼Œä¹Ÿå¯ä»¥æ·±å…¥èŠèŠã€‚



##### 3.5 ç‰©ç†å†…å­˜çš„ç®¡ç†

###### 3.5.1 ä¼™ä¼´ç³»ç»Ÿçš„ç»“æ„

ç³»ç»Ÿå†…å­˜ä¸­çš„æ¯ä¸ªç‰©ç†å†…å­˜é¡µï¼Œéƒ½å¯¹åº”äºä¸€ä¸ª`struct page`å®ä¾‹ã€‚æ¯ä¸ªå†…å­˜åŸŸéƒ½å…³è”äº†ä¸€ä¸ª`struct zone`çš„å®ä¾‹ï¼Œå…¶ä¸­ä¿å­˜äº†ç”¨äºç®¡ç†ä¼™ä¼´æ•°æ®çš„ä¸»è¦æ•°ç»„ã€‚

```c
<mmzone.h>

/* Free memory management - zoned buddy allocator.  */
#ifndef CONFIG_ARCH_FORCE_MAX_ORDER
#define MAX_PAGE_ORDER 10
#else
#define MAX_PAGE_ORDER CONFIG_ARCH_FORCE_MAX_ORDER
#endif
#define MAX_ORDER_NR_PAGES (1 << MAX_PAGE_ORDER)
#define NR_PAGE_ORDERS (MAX_PAGE_ORDER + 1)

struct zone {
	struct free_area free_area[NR_PAGE_ORDERS];
};
```

`nr_free`è¡¨ç¤ºå½“å‰å†…å­˜åŒºåŸŸä¸­ç©ºé—²é¡µå—çš„æ•°é‡ï¼Œå…¶ç»Ÿè®¡æ–¹å¼ä¾èµ–äºé˜¶æ•°ï¼ˆ`order`ï¼‰ï¼š

-   å¯¹äº0é˜¶ï¼ŒæŒ‰å•é¡µç»Ÿè®¡ï¼›
-   å¯¹äº1é˜¶ï¼ŒæŒ‰æ¯å¯¹é¡µç»Ÿè®¡ï¼›
-   å¯¹äº2é˜¶ï¼ŒæŒ‰æ¯4é¡µä¸ºä¸€ä¸ªå•ä½ç»Ÿè®¡ï¼›
-   ä¾æ­¤ç±»æ¨ï¼Œ`n`é˜¶ç©ºé—²å—è¡¨ç¤º$2^n$é¡µä¸ºä¸€ç»„çš„ç©ºé—²å—æ•°é‡ã€‚

`free_list`æ˜¯ç”¨äºè¿æ¥ç©ºé—²é¡µçš„é“¾è¡¨ã€‚

é˜¶æ˜¯ä¼™ä¼´ç³»ç»Ÿä¸­ä¸€ä¸ªéå¸¸é‡è¦çš„æœ¯è¯­ã€‚å®ƒæè¿°äº†å†…å­˜åˆ†é…çš„æ•°é‡å•ä½ã€‚å†…å­˜å—çš„é•¿åº¦æ˜¯$2^\text{order}$ï¼Œå…¶ä¸­`order`çš„èŒƒå›´ä»0åˆ°`MAX_ORDER`ã€‚è¯¥å¸¸æ•°é€šå¸¸è®¾ç½®ä¸º11ï¼Œè¿™æ„å‘³ç€ä¸€æ¬¡åˆ†é…å¯ä»¥è¯·æ±‚çš„é¡µæ•°æœ€å¤§æ˜¯$2^{11}=2 048$ã€‚ä½†å¦‚æœç‰¹å®šäºä½“ç³»ç»“æ„çš„ä»£ç è®¾ç½®äº†`CONFIG_ARCH_FORCE_MAX_ORDER`é…ç½®é€‰é¡¹ï¼Œè¯¥å€¼ä¹Ÿå¯ä»¥æ‰‹å·¥æ”¹å˜ã€‚ä¾‹å¦‚ï¼Œ`IA-64`ç³»ç»Ÿä¸Šå·¨å¤§çš„åœ°å€ç©ºé—´å¯ä»¥å¤„ç†`MAX_ORDER` = 18çš„æƒ…å½¢ï¼Œè€Œ`ARM`æˆ–`v850`ç³»ç»Ÿåˆ™ä½¿ç”¨æ›´å°çš„å€¼ï¼ˆå¦‚8æˆ–9ï¼‰ ã€‚ä½†è¿™ä¸ä¸€å®šæ˜¯ç”±è®¡ç®—æœºæ”¯æŒçš„å†…å­˜æ•°é‡æ¯”è¾ƒå°å¼•èµ·çš„ï¼Œä¹Ÿå¯èƒ½æ˜¯å†…å­˜å¯¹é½æ–¹å¼çš„è¦æ±‚æ‰€å¯¼è‡´ã€‚

æ¯ä¸ªé“¾è¡¨ä¸­çš„èŠ‚ç‚¹å°±æ˜¯ä¸€ä¸ªè¿ç»­é¡µå—ï¼Œå†…æ ¸é€šè¿‡è¯¥é¡µå—ä¸­**èµ·å§‹é¡µçš„ç¬¬ä¸€ä¸ªé¡µç»“æ„ï¼ˆé€šå¸¸æ˜¯ `struct page`ï¼‰**ä¸­çš„é“¾è¡¨æŒ‡é’ˆæ¥å°†è¿™äº›å—ç»„ç»‡æˆé“¾è¡¨ã€‚å› æ­¤ï¼ŒLinux ä¸éœ€è¦ä¸ºè¿™äº›è¿ç»­é¡µå—é¢å¤–å¼•å…¥ç‹¬ç«‹çš„æ•°æ®ç»“æ„â€”â€”é€šè¿‡å¤ç”¨ç¬¬ä¸€ä¸ªé¡µå¸§çš„å…ƒæ•°æ®å°±å¯ä»¥å°†å®ƒä»¬æŒ‚æ¥è¿›ä¼™ä¼´ç³»ç»Ÿçš„é“¾è¡¨ä¸­ï¼Œå®ç°ç®¡ç†ä¸å›æ”¶ã€‚

ä¼™ä¼´ä¸å¿…æ˜¯å½¼æ­¤è¿æ¥çš„ã€‚å¦‚æœä¸€ä¸ªå†…å­˜åŒºåœ¨åˆ†é…å…¶é—´åˆ†è§£ä¸ºä¸¤åŠï¼Œå†…æ ¸ä¼šè‡ªåŠ¨å°†æœªç”¨çš„ä¸€åŠåŠ å…¥åˆ°å¯¹åº”çš„é“¾è¡¨ä¸­ã€‚å¦‚æœåœ¨æœªæ¥çš„æŸä¸ªæ—¶åˆ»ï¼Œç”±äºå†…å­˜é‡Šæ”¾çš„ç¼˜æ•…ï¼Œä¸¤ä¸ªå†…å­˜åŒºéƒ½å¤„äºç©ºé—²çŠ¶æ€ï¼Œå¯é€šè¿‡å…¶åœ°å€åˆ¤æ–­å…¶æ˜¯å¦ä¸ºä¼™ä¼´ã€‚

åŸºäºä¼™ä¼´ç³»ç»Ÿçš„å†…å­˜ç®¡ç†ä¸“æ³¨äºæŸä¸ªç»“ç‚¹çš„æŸä¸ªå†…å­˜åŸŸï¼Œä¾‹å¦‚ï¼ŒDMAæˆ–é«˜ç«¯å†…å­˜åŸŸã€‚ä½†æ‰€æœ‰å†…

å­˜åŸŸå’Œç»“ç‚¹çš„ä¼™ä¼´ç³»ç»Ÿéƒ½é€šè¿‡å¤‡ç”¨åˆ†é…åˆ—è¡¨è¿æ¥èµ·æ¥ã€‚å›¾3-23è¯´æ˜äº†è¿™ç§å…³ç³»ã€‚

åœ¨é¦–é€‰çš„å†…å­˜åŸŸæˆ–èŠ‚ç‚¹æ— æ³•æ»¡è¶³å†…å­˜åˆ†é…è¯·æ±‚æ—¶ï¼Œé¦–å…ˆå°è¯•åŒä¸€ç»“ç‚¹çš„å¦ä¸€ä¸ªå†…å­˜åŸŸï¼Œæ¥ä¸‹æ¥å†

å°è¯•å¦ä¸€ä¸ªç»“ç‚¹ï¼Œç›´è‡³æ»¡è¶³è¯·æ±‚ã€‚

æœ€åè¦æ³¨æ„ï¼Œæœ‰å…³ä¼™ä¼´ç³»ç»Ÿå½“å‰çŠ¶æ€çš„ä¿¡æ¯å¯ä»¥åœ¨/proc/buddyinfoä¸­è·å¾—ï¼š

```bash
$ cat /proc/buddyinfo 
Node 0, zone    DMA      0    0    0    1    1    1    1    1    1    2    2 
Node 0, zone    DMA32    2    3    0    1    3    1    4    2    3    3    742 
Node 0, zone   Normal    3    1   17  142  294   97   52   53   11    6    385
```

ä¸Šè¿°è¾“å‡ºç»™å‡ºäº†å„ä¸ªå†…å­˜åŸŸä¸­æ¯ä¸ªåˆ†é…é˜¶ä¸­ç©ºé—²é¡¹çš„æ•°ç›®ï¼Œä»å·¦è‡³å³ï¼Œé˜¶ä¾æ¬¡å‡é«˜ã€‚

###### 3.5.2 é¿å…ç¢ç‰‡

åœ¨ç¬¬1ç« ç»™å‡ºçš„ç®€åŒ–è¯´æ˜ä¸­ï¼Œä¸€ä¸ªåŒé“¾è¡¨å³å¯æ»¡è¶³ä¼™ä¼´ç³»ç»Ÿçš„æ‰€æœ‰éœ€æ±‚ã€‚åœ¨å†…æ ¸ç‰ˆæœ¬2.6.23ä¹‹å‰ï¼Œçš„ç¡®æ˜¯è¿™æ ·ã€‚ä½†åœ¨å†…æ ¸2.6.24å¼€å‘æœŸé—´ï¼Œå†…æ ¸å¼€å‘è€…å¯¹ä¼™ä¼´ç³»ç»Ÿçš„äº‰è®ºæŒç»­äº†ç›¸å½“é•¿æ—¶é—´ã€‚è¿™æ˜¯å› ä¸ºä¼™ä¼´ç³»ç»Ÿæ˜¯å†…æ ¸æœ€å€¼å¾—å°Šæ•¬çš„ä¸€éƒ¨åˆ†ï¼Œå¯¹å®ƒçš„æ”¹åŠ¨ä¸ä¼šè¢«å¤§å®¶è½»æ˜“æ¥å—ã€‚

1.   ä¾æ®å¯ç§»åŠ¨æ€§ç»„ç»‡é¡µ

ä¼™ä¼´ç³»ç»Ÿçš„åŸºæœ¬åŸç†å·²ç»åœ¨ç¬¬1ç« ä¸­è®¨è®ºè¿‡ï¼Œå…¶æ–¹æ¡ˆåœ¨æœ€è¿‘å‡ å¹´é—´ç¡®å®å·¥ä½œå¾—éå¸¸å¥½ã€‚ä½†åœ¨`Linux`å†…å­˜ç®¡ç†æ–¹é¢ï¼Œæœ‰ä¸€ä¸ªé•¿æœŸå­˜åœ¨çš„é—®é¢˜ï¼šåœ¨ç³»ç»Ÿå¯åŠ¨å¹¶é•¿æœŸè¿è¡Œåï¼Œç‰©ç†å†…å­˜ä¼šäº§ç”Ÿå¾ˆå¤šç¢ç‰‡ã€‚è¯¥æƒ…å½¢å¦‚å›¾3-24æ‰€ç¤ºã€‚

å‡å®šå†…å­˜ç”±60é¡µç»„æˆï¼Œè¿™æ˜¾ç„¶ä¸æ˜¯è¶…çº§è®¡ç®—æœºï¼Œä½†ç”¨äºç¤ºä¾‹å´è¶³å¤Ÿäº†ã€‚å·¦ä¾§çš„åœ°å€ç©ºé—´ä¸­æ•£å¸ƒç€ç©ºé—²é¡µã€‚å°½ç®¡å¤§çº¦25%çš„ç‰©ç†å†…å­˜ä»ç„¶æœªåˆ†é…ï¼Œä½†æœ€å¤§çš„è¿ç»­ç©ºé—²åŒºåªæœ‰ä¸€é¡µã€‚è¿™å¯¹ç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºæ²¡æœ‰é—®é¢˜ï¼šå…¶å†…å­˜æ˜¯é€šè¿‡é¡µè¡¨æ˜ å°„çš„ï¼Œæ— è®ºç©ºé—²é¡µåœ¨ç‰©ç†å†…å­˜ä¸­çš„åˆ†å¸ƒå¦‚ä½•ï¼Œåº”ç”¨ç¨‹åºçœ‹åˆ°çš„å†…å­˜ä¼¼ä¹æ€»æ˜¯è¿ç»­çš„ã€‚å³å›¾ç»™å‡ºçš„æƒ…å½¢ä¸­ï¼Œç©ºé—²é¡µå’Œä½¿ç”¨é¡µçš„æ•°ç›®ä¸å·¦å›¾ç›¸åŒï¼Œä½†æ‰€æœ‰ç©ºé—²é¡µéƒ½ä½äºä¸€ä¸ªè¿ç»­åŒºä¸­ã€‚

ä½†å¯¹å†…æ ¸æ¥è¯´ï¼Œç¢ç‰‡æ˜¯ä¸€ä¸ªé—®é¢˜ã€‚ç”±äºï¼ˆå¤§å¤šæ•°ï¼‰ç‰©ç†å†…å­˜ä¸€è‡´æ˜ å°„åˆ°åœ°å€ç©ºé—´çš„å†…æ ¸éƒ¨åˆ†ï¼Œé‚£ä¹ˆåœ¨å·¦å›¾çš„åœºæ™¯ä¸­ï¼Œæ— æ³•æ˜ å°„æ¯”ä¸€é¡µæ›´å¤§çš„å†…å­˜åŒºã€‚å°½ç®¡è®¸å¤šæ—¶å€™å†…æ ¸éƒ½åˆ†é…çš„æ˜¯æ¯”è¾ƒå°çš„å†…å­˜ï¼Œä½†ä¹Ÿæœ‰æ—¶å€™éœ€è¦åˆ†é…å¤šäºä¸€é¡µçš„å†…å­˜ã€‚æ˜¾è€Œæ˜“è§ï¼Œåœ¨åˆ†é…è¾ƒå¤§å†…å­˜çš„æƒ…å†µä¸‹ï¼Œå³å›¾ä¸­æ‰€æœ‰å·²åˆ†é…é¡µå’Œç©ºé—²é¡µéƒ½å¤„äºè¿ç»­å†…å­˜åŒºçš„æƒ…å½¢ï¼Œæ˜¯æ›´ä¸ºå¯å–çš„ã€‚

å¾ˆæœ‰è¶£çš„ä¸€ç‚¹æ˜¯ï¼Œåœ¨å¤§éƒ¨åˆ†å†…å­˜ä»ç„¶æœªåˆ†é…æ—¶ï¼Œå°±ä¹Ÿå¯èƒ½å‘ç”Ÿç¢ç‰‡é—®é¢˜ã€‚è€ƒè™‘å›¾3-25çš„æƒ…å½¢ã€‚åªåˆ†é…äº†4é¡µï¼Œä½†å¯åˆ†é…çš„æœ€å¤§è¿ç»­åŒºåªæœ‰8é¡µï¼Œå› ä¸ºä¼™ä¼´ç³»ç»Ÿæ‰€èƒ½å·¥ä½œçš„åˆ†é…èŒƒå›´åªèƒ½æ˜¯2çš„å¹‚æ¬¡ã€‚

æˆ‘æåˆ°å†…å­˜ç¢ç‰‡åªæ¶‰åŠå†…æ ¸ï¼Œè¿™åªæ˜¯éƒ¨åˆ†æ­£ç¡®çš„ã€‚å¤§å¤šæ•°ç°ä»£CPUéƒ½æä¾›äº†ä½¿ç”¨å·¨å‹é¡µçš„å¯èƒ½æ€§ï¼Œæ¯”æ™®é€šé¡µå¤§å¾—å¤šã€‚è¿™å¯¹å†…å­˜ä½¿ç”¨å¯†é›†çš„åº”ç”¨ç¨‹åºæœ‰å¥½å¤„ã€‚åœ¨ä½¿ç”¨æ›´å¤§çš„é¡µæ—¶ï¼Œåœ°å€è½¬æ¢åå¤‡ç¼“å†²å™¨åªéœ€å¤„ç†è¾ƒå°‘çš„é¡¹ï¼Œé™ä½äº†TLBç¼“å­˜å¤±æ•ˆçš„å¯èƒ½æ€§ã€‚ä½†åˆ†é…å·¨å‹é¡µéœ€è¦è¿ç»­çš„ç©ºé—²ç‰©ç†å†…å­˜ï¼

å¾ˆé•¿æ—¶é—´ä»¥æ¥ï¼Œç‰©ç†å†…å­˜çš„ç¢ç‰‡ç¡®å®æ˜¯Linuxçš„å¼±ç‚¹ä¹‹ä¸€ã€‚å°½ç®¡å·²ç»æå‡ºäº†è®¸å¤šæ–¹æ³•ï¼Œä½†æ²¡æœ‰å“ªä¸ªæ–¹æ³•èƒ½å¤Ÿæ—¢æ»¡è¶³Linuxéœ€è¦å¤„ç†çš„å„ç§ç±»å‹å·¥ä½œè´Ÿè·æå‡ºçš„è‹›åˆ»éœ€æ±‚ï¼ŒåŒæ—¶åˆå¯¹å…¶ä»–äº‹åŠ¡å½±å“ä¸å¤§ã€‚åœ¨å†…æ ¸2.6.24å¼€å‘æœŸé—´ï¼Œé˜²æ­¢ç¢ç‰‡çš„æ–¹æ³•æœ€ç»ˆåŠ å…¥å†…æ ¸ã€‚åœ¨æˆ‘è®¨è®ºå…·ä½“ç­–ç•¥ä¹‹å‰ï¼Œæœ‰ä¸€ç‚¹éœ€è¦æ¾„æ¸…ã€‚æ–‡ä»¶ç³»ç»Ÿä¹Ÿæœ‰ç¢ç‰‡ï¼Œè¯¥é¢†åŸŸçš„ç¢ç‰‡é—®é¢˜ä¸»è¦é€šè¿‡ç¢ç‰‡åˆå¹¶å·¥å…·è§£å†³ã€‚å®ƒä»¬åˆ†ææ–‡ä»¶ç³»ç»Ÿï¼Œé‡æ–°æ’åºå·²åˆ†é…å­˜å‚¨å—ï¼Œä»è€Œå»ºç«‹è¾ƒå¤§çš„è¿ç»­å­˜å‚¨åŒºã€‚ç†è®ºä¸Šï¼Œè¯¥æ–¹æ³•å¯¹ç‰©ç†å†…å­˜ä¹Ÿæ˜¯å¯èƒ½çš„ï¼Œä½†ç”±äºè®¸å¤šç‰©ç†å†…å­˜é¡µä¸èƒ½ç§»åŠ¨åˆ°ä»»æ„ä½ç½®ï¼Œé˜»ç¢äº†è¯¥æ–¹æ³•çš„å®æ–½ã€‚å› æ­¤ï¼Œå†…æ ¸çš„æ–¹æ³•æ˜¯åç¢ç‰‡ï¼ˆanti-fragmentationï¼‰ï¼Œå³è¯•å›¾ä»æœ€åˆå¼€å§‹å°½å¯èƒ½é˜²æ­¢ç¢ç‰‡ã€‚

åç¢ç‰‡çš„å·¥ä½œåŸç†å¦‚ä½•ï¼Ÿä¸ºç†è§£è¯¥æ–¹æ³•ï¼Œæˆ‘ä»¬å¿…é¡»çŸ¥é“å†…æ ¸å°†å·²åˆ†é…é¡µåˆ’åˆ†ä¸ºä¸‹é¢3ç§ä¸åŒç±»å‹ã€‚

-   ä¸å¯ç§»åŠ¨é¡µï¼šåœ¨å†…å­˜ä¸­æœ‰å›ºå®šä½ç½®ï¼Œä¸èƒ½ç§»åŠ¨åˆ°å…¶ä»–åœ°æ–¹ã€‚æ ¸å¿ƒå†…æ ¸åˆ†é…çš„å¤§å¤šæ•°å†…å­˜å±äºè¯¥ç±»åˆ«ã€‚

-   å¯å›æ”¶é¡µï¼šä¸èƒ½ç›´æ¥ç§»åŠ¨ï¼Œä½†å¯ä»¥åˆ é™¤ï¼Œå…¶å†…å®¹å¯ä»¥ä»æŸäº›æºé‡æ–°ç”Ÿæˆã€‚ä¾‹å¦‚ï¼Œæ˜ å°„è‡ªæ–‡ä»¶çš„æ•°æ®å±äºè¯¥ç±»åˆ«ã€‚`kswapd`å®ˆæŠ¤è¿›ç¨‹ä¼šæ ¹æ®å¯å›æ”¶é¡µè®¿é—®çš„é¢‘ç¹ç¨‹åº¦ï¼Œå‘¨æœŸæ€§é‡Šæ”¾æ­¤ç±»å†…å­˜ã€‚è¿™æ˜¯ä¸€ä¸ªå¤æ‚çš„è¿‡ç¨‹ï¼Œæœ¬èº«å°±éœ€è¦è¯¦ç»†è®ºè¿°ï¼šç¬¬18ç« è¯¦ç»†æè¿°äº†é¡µé¢å›æ”¶ã€‚ç›®å‰ï¼Œäº†è§£åˆ°å†…æ ¸ä¼šåœ¨å¯å›æ”¶é¡µå æ®äº†å¤ªå¤šå†…å­˜æ—¶è¿›è¡Œå›æ”¶ï¼Œå°±è¶³å¤Ÿäº†ã€‚å¦å¤–ï¼Œåœ¨å†…å­˜çŸ­ç¼ºï¼ˆå³åˆ†é…å¤±è´¥ï¼‰æ—¶ä¹Ÿå¯ä»¥å‘èµ·é¡µé¢å›æ”¶ã€‚æœ‰å…³å†…æ ¸å‘èµ·é¡µé¢å›æ”¶çš„æ—¶æœºï¼Œæ›´å…·ä½“çš„ä¿¡æ¯è¯·å‚è€ƒä¸‹æ–‡ã€‚

-   å¯ç§»åŠ¨é¡µå¯ä»¥éšæ„åœ°ç§»åŠ¨ã€‚å±äºç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºçš„é¡µå±äºè¯¥ç±»åˆ«ã€‚å®ƒä»¬æ˜¯é€šè¿‡é¡µè¡¨æ˜ å°„çš„ã€‚å¦‚æœå®ƒä»¬å¤åˆ¶åˆ°æ–°ä½ç½®ï¼Œé¡µè¡¨é¡¹å¯ä»¥ç›¸åº”åœ°æ›´æ–°ï¼Œåº”ç”¨ç¨‹åºä¸ä¼šæ³¨æ„åˆ°ä»»ä½•äº‹ã€‚

é¡µçš„å¯ç§»åŠ¨æ€§ï¼Œä¾èµ–è¯¥é¡µå±äº3ç§ç±»åˆ«çš„å“ªä¸€ç§ã€‚å†…æ ¸ä½¿ç”¨çš„åç¢ç‰‡æŠ€æœ¯ï¼Œå³åŸºäºå°†å…·æœ‰ç›¸åŒå¯ç§»åŠ¨æ€§çš„é¡µåˆ†ç»„çš„æ€æƒ³ã€‚ä¸ºä»€ä¹ˆè¿™ç§æ–¹æ³•æœ‰åŠ©äºå‡å°‘ç¢ç‰‡ï¼Ÿå›æƒ³å›¾3-25ä¸­ï¼Œç”±äºé¡µæ— æ³•ç§»åŠ¨ï¼Œå¯¼è‡´åœ¨åŸæœ¬å‡ ä¹å…¨ç©ºçš„å†…å­˜åŒºä¸­æ— æ³•è¿›è¡Œè¿ç»­åˆ†é…ã€‚æ ¹æ®é¡µçš„å¯ç§»åŠ¨æ€§ï¼Œå°†å…¶åˆ†é…åˆ°ä¸åŒçš„åˆ—è¡¨ä¸­ï¼Œå³å¯é˜²æ­¢è¿™ç§æƒ…å½¢ã€‚ä¾‹å¦‚ï¼Œä¸å¯ç§»åŠ¨çš„é¡µä¸èƒ½ä½äºå¯ç§»åŠ¨å†…å­˜åŒºçš„ä¸­é—´ï¼Œå¦åˆ™å°±æ— æ³•ä»è¯¥å†…å­˜åŒºåˆ†é…è¾ƒå¤§çš„è¿ç»­å†…å­˜å—ã€‚

æƒ³ä¸€ä¸‹ï¼Œå›¾3-25ä¸­å¤§å¤šæ•°ç©ºé—²é¡µéƒ½å±äºå¯å›æ”¶çš„ç±»åˆ«ï¼Œè€Œåˆ†é…çš„é¡µåˆ™æ˜¯ä¸å¯ç§»åŠ¨çš„ã€‚å¦‚æœè¿™äº›é¡µèšé›†åˆ°ä¸¤ä¸ªä¸åŒçš„åˆ—è¡¨ä¸­ï¼Œå¦‚å›¾3-26æ‰€ç¤ºã€‚åœ¨ä¸å¯ç§»åŠ¨é¡µä¸­ä»ç„¶éš¾ä»¥æ‰¾åˆ°è¾ƒå¤§çš„è¿ç»­ç©ºé—²ç©ºé—´ï¼Œä½†å¯¹å¯å›æ”¶çš„é¡µï¼Œå°±å®¹æ˜“å¤šäº†ã€‚

ä½†è¦æ³¨æ„ï¼Œä»æœ€åˆå¼€å§‹ï¼Œå†…å­˜å¹¶æœªåˆ’åˆ†ä¸ºå¯ç§»åŠ¨æ€§ä¸åŒçš„åŒºã€‚è¿™äº›æ˜¯åœ¨è¿è¡Œæ—¶å½¢æˆçš„ã€‚å†…æ ¸çš„å¦ä¸€ç§æ–¹æ³•ç¡®å®å°†å†…å­˜åˆ†åŒºï¼Œåˆ†åˆ«ç”¨äºå¯ç§»åŠ¨é¡µå’Œä¸å¯ç§»åŠ¨é¡µçš„åˆ†é…ï¼Œæˆ‘ä¼šä¸‹æ–‡è®¨è®ºå…¶å·¥ä½œåŸç†ã€‚ä½†è¿™ç§åˆ’åˆ†å¯¹è¿™é‡Œæè¿°çš„æ–¹æ³•æ˜¯ä¸å¿…è¦çš„ã€‚

**æ•°æ®ç»“æ„**

å°½ç®¡å†…æ ¸ä½¿ç”¨çš„åç¢ç‰‡æŠ€æœ¯å“æœ‰æˆæ•ˆï¼Œå®ƒå¯¹ä¼™ä¼´åˆ†é…å™¨çš„ä»£ç å’Œæ•°æ®ç»“æ„å‡ ä¹æ²¡æœ‰å½±å“ã€‚å†…æ ¸å®šä¹‰äº†ä¸€äº›å®æ¥è¡¨ç¤ºä¸åŒçš„è¿ç§»ç±»å‹ï¼š

```c
enum migratetype {
	MIGRATE_UNMOVABLE,
	MIGRATE_MOVABLE,
	MIGRATE_RECLAIMABLE,
	MIGRATE_PCPTYPES,	/* the number of types on the pcp lists */
	MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,
#ifdef CONFIG_CMA
	/*
	 * MIGRATE_CMA migration type is designed to mimic the way
	 * ZONE_MOVABLE works.  Only movable pages can be allocated
	 * from MIGRATE_CMA pageblocks and page allocator never
	 * implicitly change migration type of MIGRATE_CMA pageblock.
	 *
	 * The way to use it is to change migratetype of a range of
	 * pageblocks to MIGRATE_CMA which can be done by
	 * __free_pageblock_cma() function.
	 */
	MIGRATE_CMA,
#endif
#ifdef CONFIG_MEMORY_ISOLATION
	MIGRATE_ISOLATE,	/* can't allocate from here */
#endif
	MIGRATE_TYPES
};
```

å¯¹ä¼™ä¼´ç³»ç»Ÿæ•°æ®ç»“æ„çš„ä¸»è¦è°ƒæ•´ï¼Œæ˜¯å°†ç©ºé—²åˆ—è¡¨åˆ†è§£ä¸º`MIGRATE_TYPE`ä¸ªåˆ—è¡¨ï¼š

```c
struct free_area {
	struct list_head free_list[MIGRATE_TYPES];
	unsigned long    nr_free;
};
```

â€‹	`nr_free`ç»Ÿè®¡äº†æ‰€æœ‰åˆ—è¡¨ä¸Šç©ºé—²é¡µçš„æ•°ç›®ï¼Œè€Œæ¯ç§è¿ç§»ç±»å‹éƒ½å¯¹åº”äºä¸€ä¸ªç©ºé—²åˆ—è¡¨ã€‚å®`for_each_migratetype_order(order, type)`å¯ç”¨äºè¿­ä»£æŒ‡å®šè¿ç§»ç±»å‹çš„æ‰€æœ‰åˆ†é…é˜¶ã€‚

å¦‚æœå†…æ ¸æ— æ³•æ»¡è¶³é’ˆå¯¹æŸä¸€ç»™å®šè¿ç§»ç±»å‹çš„åˆ†é…è¯·æ±‚ï¼Œä¼šæ€ä¹ˆæ ·ï¼Ÿæ­¤å‰å·²ç»å‡ºç°è¿‡ä¸€ä¸ªç±»ä¼¼çš„é—®é¢˜ï¼Œå³ç‰¹å®šçš„`NUMA`å†…å­˜åŸŸæ— æ³•æ»¡è¶³åˆ†é…è¯·æ±‚æ—¶ã€‚å†…æ ¸åœ¨è¿™ç§æƒ…å†µä¸‹çš„åšæ³•æ˜¯ç±»ä¼¼çš„ï¼Œæä¾›äº†ä¸€ä¸ªå¤‡ç”¨åˆ—è¡¨ï¼Œè§„å®šäº†åœ¨æŒ‡å®šåˆ—è¡¨ä¸­æ— æ³•æ»¡è¶³åˆ†é…è¯·æ±‚æ—¶ï¼Œæ¥ä¸‹æ¥åº”ä½¿ç”¨å“ªä¸€ç§è¿ç§»ç±»å‹ï¼š

```c
<mm/page_alloc.c>
/*
 * This array describes the order lists are fallen back to when
 * the free lists for the desirable migrate type are depleted
 *
 * The other migratetypes do not have fallbacks.
 */
static int fallbacks[MIGRATE_PCPTYPES][MIGRATE_PCPTYPES - 1] = {
	[MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE   },
	[MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE },
	[MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE   },
};
```

è¯¥æ•°æ®ç»“æ„å¤§ä½“ä¸Šæ˜¯è‡ªæ˜çš„ï¼šåœ¨å†…æ ¸æƒ³è¦åˆ†é…ä¸å¯ç§»åŠ¨é¡µæ—¶ï¼Œå¦‚æœå¯¹åº”é“¾è¡¨ä¸ºç©ºï¼Œåˆ™åé€€åˆ°å¯å›æ”¶é¡µé“¾è¡¨ï¼Œæ¥ä¸‹æ¥åˆ°å¯ç§»åŠ¨é¡µé“¾è¡¨ã€‚





<hr/>

âœ… `Linux`å†…æ ¸æ˜¯å¦ä½¿ç”¨`bitmap`è¡¨ç¤ºæ•´ä¸ªç‰©ç†å†…å­˜ï¼Ÿ

æ˜¯ï¼Œä½†ä¸æ˜¯ç›´æ¥æ‹¿`bitmap`ä»£è¡¨æ•´ä¸ªç‰©ç†å†…å­˜åˆ†é…çŠ¶æ€ã€‚åœ¨`Linux`çš„å†…å­˜ç®¡ç†ä¸­ï¼Œ`bitmap`ç”¨äºä¸€äº›å­ç³»ç»Ÿï¼Œæ¯”å¦‚ï¼š

-   `buddy allocator`ï¼šä½¿ç”¨`bitmap`æ¥è·Ÿè¸ªæ¯é˜¶æ¯é¡µå—æ˜¯å¦ç©ºé—²
-   `page allocator`ï¼šæ¯ä¸ªé¡µçš„å…ƒæ•°æ®ç”±`struct page`è¡¨ç¤ºï¼Œæ•´ä¸ªç‰©ç†é¡µæ•°ç»„`mem_map[]`æ˜¯ä¸»æ§
-   `SLAB/SLUB/SLOB allocators`ï¼šä¹Ÿä½¿ç”¨`bitmap`ç®¡ç†å°å—åˆ†é…ï¼ˆ<1é¡µï¼‰

âœ… ç‰©ç†å†…å­˜åˆ’åˆ†æˆé˜¶çº§ï¼ˆ`order`ï¼‰ç®¡ç†æ˜¯å¦åŸºäº`bitmap`ï¼Ÿ

æ˜¯çš„ï¼Œ`buddy system`åœ¨æ¯ä¸ª`zone`çš„æ¯ä¸ª`order`ä¸­éƒ½æœ‰ä¸€ä¸ª`freelist`å’Œ`bitmap`ã€‚

-   `Linux`å†…æ ¸å°†ç‰©ç†å†…å­˜åˆ†ä¸ºä¸åŒçš„`zone`ï¼ˆ`DMA, Normal, HighMem...`ï¼‰
-   æ¯ä¸ª`zone`ç»´æŠ¤ä¸€ä¸ª`free_area[]`æ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ è¡¨ç¤ºä¸€ä¸ªé˜¶

```c
/* file: include/linux/mmzone.h */
struct zone {
  /* zone_start_pfn == zone_start_paddr >> PAGE_SHIFT */
	unsigned long		zone_start_pfn;

	/*
	 * spanned_pages is the total pages spanned by the zone, including
	 * holes, which is calculated as:
	 * 	spanned_pages = zone_end_pfn - zone_start_pfn;
	 *
	 * present_pages is physical pages existing within the zone, which
	 * is calculated as:
	 *	present_pages = spanned_pages - absent_pages(pages in holes);
	 *
	 * present_early_pages is present pages existing within the zone
	 * located on memory available since early boot, excluding hotplugged
	 * memory.
	 *
	 * managed_pages is present pages managed by the buddy system, which
	 * is calculated as (reserved_pages includes pages allocated by the
	 * bootmem allocator):
	 *	managed_pages = present_pages - reserved_pages;
	 *
	 * cma pages is present pages that are assigned for CMA use
	 * (MIGRATE_CMA).
	 *
	 * So present_pages may be used by memory hotplug or memory power
	 * management logic to figure out unmanaged pages by checking
	 * (present_pages - managed_pages). And managed_pages should be used
	 * by page allocator and vm scanner to calculate all kinds of watermarks
	 * and thresholds.
	 *
	 * Locking rules:
	 *
	 * zone_start_pfn and spanned_pages are protected by span_seqlock.
	 * It is a seqlock because it has to be read outside of zone->lock,
	 * and it is done in the main allocator path.  But, it is written
	 * quite infrequently.
	 *
	 * The span_seq lock is declared along with zone->lock because it is
	 * frequently read in proximity to zone->lock.  It's good to
	 * give them a chance of being in the same cacheline.
	 *
	 * Write access to present_pages at runtime should be protected by
	 * mem_hotplug_begin/done(). Any reader who can't tolerant drift of
	 * present_pages should use get_online_mems() to get a stable value.
	 */
	atomic_long_t		managed_pages;
	unsigned long		spanned_pages;
	unsigned long		present_pages;
	struct free_area free_area[MAX_ORDER]; // MAX_ORDER=11ï¼Œé˜¶0~10
};
```

-   æ¯ä¸ª `free_area` é•¿è¿™æ ·ï¼š

```
c


å¤åˆ¶ç¼–è¾‘
struct free_area {
    struct list_head free_list; // åŒå‘é“¾è¡¨ï¼Œè®°å½•ç©ºé—²å—
    unsigned long *map;         // bitmapï¼Œè®°å½•æ¯ä¸ªå—æ˜¯å¦ç©ºé—²
};
```

### bitmap çš„ä½œç”¨ï¼š

-   æ ‡è®°æŸä¸ªé˜¶çº§çš„é¡µå—æ˜¯å¦ç©ºé—²
-   å’Œ freelist ä¸€èµ·æ”¯æŒå¿«é€Ÿåˆå¹¶/æ‹†åˆ†

------

## âœ… 3. å†…å­˜æ˜¯å¦‚ä½•åˆ†é˜¶ç®¡ç†çš„ï¼Ÿ

ä»¥ 1GB å†…å­˜ä¸ºä¾‹ï¼ˆä¸è€ƒè™‘ NUMA å’Œ zoneï¼‰ï¼š

-   æ‹†åˆ†æˆ 4KB é¡µï¼ˆ2^20 / 2^12 = 2^8 = 256K é¡µï¼‰
-   æ¯ä¸ª `struct page` ä»£è¡¨ä¸€ä¸ªç‰©ç†é¡µï¼Œåœ¨ boot æ—¶åˆå§‹åŒ– `mem_map[]`
-   æ¯ä¸ª zone å»ºç«‹é˜¶çº§æ•°ç»„ `free_area[0...MAX_ORDER-1]`
-   æ¯é˜¶ä¸‹æœ‰è‹¥å¹²ä¸ª blockï¼Œæ¯ block æ˜¯ 2^order é¡µ
-   æ¯é˜¶æœ‰å¯¹åº”çš„ bitmap å’Œ free_list

`/proc/zoneinfo` æ˜¯ Linux å†…æ ¸æä¾›çš„ä¸€ä¸ªæ–‡ä»¶ï¼Œç”¨äºæ˜¾ç¤ºç³»ç»Ÿå†…å­˜åŒºåŸŸ(zone)çš„è¯¦ç»†ä¿¡æ¯ã€‚è¿™äº›ä¿¡æ¯å¯¹äºç†è§£ç³»ç»Ÿå†…å­˜ä½¿ç”¨æƒ…å†µå’Œæ€§èƒ½è°ƒä¼˜éå¸¸æœ‰å¸®åŠ©ã€‚

## ä¸»è¦éƒ¨åˆ†è§£æ

### 1. èŠ‚ç‚¹å’ŒåŒºåŸŸç»“æ„

è¾“å‡ºæŒ‰ NUMA èŠ‚ç‚¹(Node)å’Œå†…å­˜åŒºåŸŸ(zone)ç»„ç»‡ï¼š

text

```
Node 0, zone      DMA
Node 0, zone    DMA32
Node 0, zone   Normal
Node 0, zone  Movable
Node 0, zone   Device
```

-   **Node 0**ï¼šè¡¨ç¤ºç¬¬ä¸€ä¸ª NUMA èŠ‚ç‚¹(åœ¨å•å¤„ç†å™¨ç³»ç»Ÿä¸­é€šå¸¸åªæœ‰ Node 0)
-   **zone**ï¼šå†…å­˜åŒºåŸŸç±»å‹ï¼Œå¸¸è§çš„æœ‰ï¼š
    -   **DMA**ï¼šç›´æ¥å†…å­˜è®¿é—®åŒºåŸŸ(é€šå¸¸ <16MB)
    -   **DMA32**ï¼š32ä½è®¾å¤‡å¯è®¿é—®åŒºåŸŸ(é€šå¸¸ <4GB)
    -   **Normal**ï¼šæ™®é€šå†…å­˜åŒºåŸŸ
    -   **Movable**ï¼šå¯ç§»åŠ¨å†…å­˜åŒºåŸŸ(ç”¨äºå†…å­˜çƒ­æ’æ‹”)
    -   **Device**ï¼šè®¾å¤‡å†…å­˜åŒºåŸŸ

### 2. å…³é”®å­—æ®µè§£é‡Š

æ¯ä¸ªåŒºåŸŸåŒ…å«ä»¥ä¸‹é‡è¦ä¿¡æ¯ï¼š

#### å†…å­˜ç»Ÿè®¡

-   **pages free**ï¼šç©ºé—²é¡µé¢æ•°
-   **min/low/high**ï¼šå†…å­˜æ°´ä½æ ‡è®°ï¼Œç”¨äºå†…å­˜å›æ”¶
    -   `min`ï¼šæœ€ä½æ°´ä½ï¼Œä½äºæ­¤å€¼å¼€å§‹ç§¯æå›æ”¶å†…å­˜
    -   `low`ï¼šä½æ°´ä½ï¼Œä½äºæ­¤å€¼å¼€å§‹æ¸©å’Œå›æ”¶
    -   `high`ï¼šé«˜æ°´ä½ï¼Œå›æ”¶å†…å­˜åˆ°æ­¤å€¼åœæ­¢
-   **spanned/present/managed**ï¼š
    -   `spanned`ï¼šåŒºåŸŸæ€»å¤§å°(åŒ…æ‹¬ç©ºæ´)
    -   `present`ï¼šå®é™…å­˜åœ¨çš„ç‰©ç†å†…å­˜
    -   `managed`ï¼šç”±ä¼™ä¼´ç³»ç»Ÿç®¡ç†çš„å†…å­˜

#### ä½¿ç”¨æƒ…å†µç»Ÿè®¡

-   **nr_*** ç³»åˆ—ï¼šå„ç§ç±»å‹é¡µé¢çš„è®¡æ•°
    -   `nr_inactive_anon`ï¼šéæ´»è·ƒçš„åŒ¿åé¡µ
    -   `nr_active_anon`ï¼šæ´»è·ƒçš„åŒ¿åé¡µ(è¿›ç¨‹å †æ ˆã€å †ç­‰)
    -   `nr_inactive_file`ï¼šéæ´»è·ƒçš„æ–‡ä»¶ç¼“å­˜é¡µ
    -   `nr_active_file`ï¼šæ´»è·ƒçš„æ–‡ä»¶ç¼“å­˜é¡µ
    -   `nr_slab_reclaimable`ï¼šå¯å›æ”¶çš„slabå†…å­˜
    -   `nr_slab_unreclaimable`ï¼šä¸å¯å›æ”¶çš„slabå†…å­˜
    -   `nr_mapped`ï¼šè¢«æ˜ å°„åˆ°è¿›ç¨‹åœ°å€ç©ºé—´çš„é¡µé¢

#### NUMAç›¸å…³ç»Ÿè®¡

-   **numa_hit**ï¼šåœ¨æœ¬èŠ‚ç‚¹åˆ†é…æˆåŠŸæ¬¡æ•°
-   **numa_miss**ï¼šåœ¨æœ¬èŠ‚ç‚¹åˆ†é…å¤±è´¥æ¬¡æ•°
-   **numa_local**ï¼šæœ¬åœ°åˆ†é…æ¬¡æ•°

#### æ¯CPUé¡µç¼“å­˜(pagesets)

æ˜¾ç¤ºæ¯ä¸ªCPUæ ¸å¿ƒçš„é¡µç¼“å­˜çŠ¶æ€ï¼š

-   `count`ï¼šå½“å‰ç¼“å­˜é¡µé¢æ•°
-   `high`ï¼šé«˜æ°´ä½æ ‡è®°
-   `batch`ï¼šæ‰¹é‡æ“ä½œå¤§å°

### 3. å…·ä½“åŒºåŸŸåˆ†æ

#### DMA åŒºåŸŸ

-   éå¸¸å°çš„å†…å­˜åŒºåŸŸ(ä»…4095é¡µï¼Œçº¦16MB)
-   ä¸»è¦ç”¨äºæ—§è®¾å¤‡DMAæ“ä½œ
-   å½“å‰ç©ºé—²é¡µé¢å¾ˆå°‘(3576é¡µï¼Œçº¦14MB)

#### DMA32 åŒºåŸŸ

-   ä¸­ç­‰å¤§å°åŒºåŸŸ(çº¦3GBç‰©ç†å†…å­˜)
-   ç©ºé—²å†…å­˜è¾ƒå¤š(426926é¡µï¼Œçº¦1.7GB)
-   æ–‡ä»¶ç¼“å­˜è¾ƒå°‘ï¼ŒåŒ¿åé¡µè¾ƒå¤š

#### Normal åŒºåŸŸ

-   ä¸»è¦å†…å­˜åŒºåŸŸ(çº¦5GBç‰©ç†å†…å­˜)
-   ç©ºé—²å†…å­˜è¾ƒå°‘(13307é¡µï¼Œçº¦52MB)
-   æ–‡ä»¶ç¼“å­˜å’ŒåŒ¿åé¡µéƒ½å¾ˆå¤š
-   æœ‰133é¡µç­‰å¾…å†™å…¥ç£ç›˜(nr_zone_write_pending)

### 4. ç³»ç»Ÿæ•´ä½“å†…å­˜çŠ¶å†µ

ä»è¾“å‡ºå¯ä»¥çœ‹å‡ºï¼š

1.  ç³»ç»Ÿä¸»è¦ä½¿ç”¨NormalåŒºåŸŸå†…å­˜ï¼Œä¸”ç©ºé—²å†…å­˜è¾ƒå°‘(ä»…52MB)
2.  DMA32åŒºåŸŸè¿˜æœ‰è¾ƒå¤šç©ºé—²å†…å­˜(1.7GB)
3.  æ–‡ä»¶ç¼“å­˜å ç”¨è¾ƒå¤šå†…å­˜(çº¦732902é¡µï¼Œ2.8GB)
4.  åŒ¿åé¡µä¹Ÿå ç”¨è¾ƒå¤šå†…å­˜(çº¦650843é¡µï¼Œ2.5GB)
5.  æœ‰144é¡µè„æ•°æ®ç­‰å¾…å†™å…¥(nr_dirty)
6.  ç³»ç»Ÿæ²¡æœ‰ä½¿ç”¨äº¤æ¢ç©ºé—´(nr_swapcached=0)

### 5. æ€§èƒ½è°ƒä¼˜æç¤º

-   ç³»ç»ŸNormalåŒºåŸŸå†…å­˜å‹åŠ›è¾ƒå¤§(ç©ºé—²å†…å­˜æ¥è¿‘lowæ°´ä½)
-   å¦‚æœåº”ç”¨æ€§èƒ½ä¸‹é™ï¼Œå¯èƒ½éœ€è¦ï¼š
    -   å‡å°‘å†…å­˜ä½¿ç”¨
    -   å¢åŠ swapç©ºé—´
    -   è°ƒæ•´vm.swappinesså‚æ•°
    -   ä¼˜åŒ–åº”ç”¨ä½¿ç”¨æ–‡ä»¶ç¼“å­˜çš„æ–¹å¼

è¿™ä¸ªè¾“å‡ºå¯¹äºè¯Šæ–­å†…å­˜ç›¸å…³æ€§èƒ½é—®é¢˜éå¸¸æœ‰ç”¨ï¼Œç‰¹åˆ«æ˜¯åœ¨å†…å­˜ä¸è¶³æˆ–äº¤æ¢é¢‘ç¹çš„æƒ…å†µä¸‹ã€‚