---
date: 2025-07-27
layout: post
title: 技术背景【第二章】
categories: Linux
tags: [Linux, BPF] 
---

第1章介绍了BPF性能工具所涉及的各种技术，而本章将对它们进行更深入的讲解，包括它们的历史、接口、内部机制，以及与`BPF`的结合使用。

本章是全书中技术深度最高的一章。为了简洁起见，内容默认你已具备一定的内核内部结构和指令级编程方面的知识。

本章的学习目标并不是要你死记硬背每一页内容，而是希望你能够：

-   理解`BPF`的起源，以及扩展`BPF`（`eBPF`）在今天的作用；
-   掌握栈帧指针遍历（`frame pointer stack walking`）等常用技术；
-   理解火焰图（`flame graph`）的构成与分析方法；
-   掌握`kprobe`和`uprobe`的用法，及其稳定性相关的注意事项；
-   理解`tracepoint`、`USDT`探针和动态`USDT`的角色；
-   了解性能监控计数器（`PMC`）以及它们如何结合`BPF`使用；
-   掌握一些面向未来的发展方向：如`BTF`以及其它`BPF`栈遍历器。

理解本章将帮助你更深入地掌握本书后续内容。但如果你此刻只是想快速上手`BPF`工具来解决实际问题，也可以先略读本章，待需要时再回来深入学习。

第3章将正式带你开始使用`BPF`工具，寻找系统中的性能优化机会。

##### 🌲 `BPF`技术关系图

图2-1展示了本章涉及的多项`BPF`相关技术及它们之间的关系。

![](/assets/img/linux/bpf/figure2-1.png)

##### 🌲 `BPF`

`BPF`（`Berkeley Packet Filter`）最初是在`BSD`操作系统上开发的，首次发表于1992年的论文《`The BSD Packet Filter: A New Architecture for User-level Packet Capture`》[McCanne 92]。该论文在1993年美国圣地亚哥召开的`USENIX`冬季会议上发表，同期还有《`Measurement, Analysis, and Improvement of UDP/IP Throughput for the DECstation 5000`》。虽然`DECstation`早已成为历史，但`BPF`却得以延续，并成为业界标准的包过滤解决方案。

`BPF`的工作原理非常有趣：用户通过定义一段针对`BPF`虚拟机的指令集（通常称为`BPF`字节码）来描述过滤逻辑，然后将这段指令传递给内核，由内核中的解释器执行。这样一来，包过滤的过程可以直接在内核态完成，避免了将每个数据包拷贝到用户空间的高昂开销，从而极大提升了像`tcpdump(8)`这样的工具的性能。

更重要的是，这种机制也具备了安全性：来自用户空间的`BPF`程序可以在执行前被内核验证为“安全”。因为早期的包过滤需要在内核中完成，因此安全性是一项硬性要求。

图2-2展示了这一工作机制的流程。

![](/assets/img/linux/bpf/figure2-2.png)

你可以使用`tcpdump(8)`的`-d`选项来打印其使用的`BPF`指令，以查看它是如何处理过滤表达式的。例如：

```bash
$ tcpdump -d host 127.0.0.1 and port 80
Warning: assuming Ethernet
(000) ldh      [12]
(001) jeq      #0x800           jt 2	jf 18
(002) ld       [26]
(003) jeq      #0x7f000001      jt 6	jf 4
(004) ld       [30]
(005) jeq      #0x7f000001      jt 6	jf 18
(006) ldb      [23]
(007) jeq      #0x84            jt 10	jf 8
(008) jeq      #0x6             jt 10	jf 9
(009) jeq      #0x11            jt 10	jf 18
(010) ldh      [20]
(011) jset     #0x1fff          jt 18	jf 12
(012) ldxb     4*([14]&0xf)
(013) ldh      [x + 14]
(014) jeq      #0x50            jt 17	jf 15
(015) ldh      [x + 16]
(016) jeq      #0x50            jt 17	jf 18
(017) ret      #262144
(018) ret      #0
```

原始的`BPF`（现在通常称为“经典`BPF`”）是一个功能受限的虚拟机。它只有两个寄存器、一个由16个内存槽组成的临时内存区域（`scratch memory`）和一个程序计数器（`PC`）。这些寄存器全都基于32位操作。经典`BPF`于1997年被引入`Linux`内核，从 2.1.75版本开始。

随着`BPF`被集成进`Linux`内核，它逐步得到了多个重要的改进：

-   2011年7月，`Eric Dumazet`在`Linux 3.0`中加入了`BPF`的即时编译器（`JIT`），使其相较于解释执行获得了性能提升。
-   2012年，`Will Drewry`将`BPF`应用于`seccomp`（安全计算）系统调用策略中，这标志着`BPF`首次被用于网络以外的场景，并展示了它作为通用执行引擎的潜力。

##### 🌲 扩展`BPF`（`eBPF`）

扩展`BPF`（`eBPF`）最初由**Alexei Starovoitov**在`PLUMgrid`工作期间提出，当时该公司正在探索构建软件定义网络（`SDN`）的新方式。这项提议是对`BPF`近20年来的第一次重大更新，目标是将`BPF`扩展为一个通用虚拟机。

当该提案尚处于草案阶段时，来自`Red Hat`的内核开发者**Daniel Borkmann**协助对其进行了重构，使其能被接受进入内核主线，作为现有`BPF`的替代实现。这一扩展`BPF`版本最终被成功并入主线，并随后得到了众多开发者的贡献。

`eBPF`的关键改进包括：

-   增加了更多寄存器；
-   将字长从32位提升到64位；
-   引入了灵活的`BPF`“映射”（`map`）机制用于数据存储；
-   允许调用部分受限的内核函数；
-   `JIT`编译器可将`eBPF`程序一一映射为本地指令和寄存器，从而复用原本为原生代码优化的技术；
-   同时，`BPF`校验器（`verifier`）也得到了增强，以支持这些扩展并拒绝任何不安全的代码。

表2-1展示了经典`BPF`与扩展`BPF`之间的主要差异。

| Factor                  | Classic BPF                | Extended BPF                                                 |
| ----------------------- | -------------------------- | ------------------------------------------------------------ |
| Register count          | 2: A, X                    | 10: R0–R9, plus R10 as a read-only frame pointer             |
| Register width          | 32-bit                     | 64-bit                                                       |
| Storage                 | 16 memory slots: M[0–15]   | 512 bytes of stack space, plus infinite "map" storage        |
| Restricted kernel calls | Very limited, JIT specific | Yes, via the bpf_call instruction                            |
| Event targets           | Packets, seccomp-BPF       | Packets, kernel functions, user functions, tracepoints, user markers, PMCs |

`Alexei`最初的补丁集发布于2013年9月，标题为“extended BPF”。到2013年12月，他已开始提议将其用于追踪过滤器。经过与`Daniel`的反复讨论与开发，这些补丁从2014年3月开始合并进`Linux`主线内核。

-   `JIT`相关组件合并于`Linux 3.15`（2014年6月发布）；
-   控制`BPF`的系统调用`bpf(2)`合并于`Linux 3.18`（2014年12月发布）；
-   在后续的`Linux 4.x`系列中，`BPF`又陆续加入了对`kprobes`、`uprobes`、`tracepoints`和`perf_events`的支持。

在最初的补丁集中，这项技术曾被简称为**eBPF**，但`Alexei`后来统一称之为**BPF**。目前在`net-dev`邮件列表中，所有`BPF`相关开发也都以“BPF”来称呼它。

`Linux`中`BPF`运行时的架构如图2-3所示。`BPF`程序在执行前会经过**BPF 校验器（verifier）**的检查，之后再由`BPF`虚拟机执行。`BPF`虚拟机本身既可以解释执行，也可以使用`JIT`编译器将其转为本地指令直接运行。

![](/assets/img/linux/bpf/figure2-3.png)

校验器的一个重要职责是拒绝不安全的操作（如无限循环），因为`BPF`程序必须在**有限时间**内完成执行。此外，`BPF`还能通过`helper`函数访问内核状态，并使用`BPF map`进行状态存储。

`BPF`程序的执行通常是由某些事件触发的，例如：

-   `kprobes`（内核函数入口/出口）
-   `uprobes`（用户空间函数入口/出口）
-   `tracepoints`（内核预定义埋点）

接下来的小节将介绍：

-   性能工具为什么需要`BPF`；
-   `eBPF`编程的方式；
-   如何查看`BPF`指令；
-   `BPF`的`API`；
-   `BPF`的限制；
-   以及`BTF`（`BPF Type Format`）的作用。

这些内容为理解`bpftrace`与`BCC`在背后是如何运作的奠定基础。

###### 🍃 为什么性能分析工具需要`BPF`

性能分析工具之所以使用扩展`BPF`（`eBPF`），部分原因在于其**可编程性**。借助`BPF`程序，可以执行自定义的延迟计算和统计汇总。这些特性本身就足以打造一个非常强大的工具，事实上，许多现有的跟踪工具也具备类似功能。

但**BPF的独特之处**在于：它不仅功能强大，还具有**高效性与生产环境的安全性**，而且是**内建于Linux内核**之中的。这意味着我们可以**在生产系统中直接运行这些工具**，而无需引入额外的内核模块或组件。

下面我们通过一个输出示例和示意图，了解性能工具是如何利用`BPF`的。这个例子来自我早期发布的一个`BPF`工具——`bitehist`，它将磁盘`I/O`的数据大小以直方图形式展示。

```bash
# bitehist
Tracing block device I/O... Interval 5 secs. Ctrl-C to end.
kbytes 				: count 			distribution
0    -> 1 		: 3 					| 																			|
2   -> 3 			: 0 					| 																			|
4   -> 7 			: 3395 				|************************************* 	|
8   -> 15 		: 1 					| 																			|
16  -> 31 		: 2 					| 																			|
32  -> 63 		: 738 				|******* 																|
64  -> 127 		: 3 					| 																			|
128 -> 255 		:	1 					| 																			|
```

图2-4展示了`BPF`是如何提升该工具效率的。

![](/assets/img/linux/bpf/figure2-4.png)

图2-4使用`BPF`前后的直方图生成方式对比

关键的改变在于：**这个直方图是在内核上下文中生成的**，从而大大减少了需要复制到用户态的数据量。这种效率的提升非常显著，使得原本因代价过高无法在生产中使用的工具变得可行。

在使用`BPF`之前，生成这样的直方图需要以下步骤：

1.  **在内核中**：启用对磁盘`I/O`事件的观测（`instrumentation`）。
2.  **每次事件发生时**：向`perf`缓冲区写入一条记录。如果使用`tracepoint`（推荐的方式），记录会包含多个字段的元数据。
3.  **在用户空间**：定期将整个`perf`缓冲区复制到用户空间。
4.  **在用户空间**：遍历所有事件，只解析其中的`bytes`字段，其它字段会被忽略。
5.  **在用户空间**：对`bytes`字段生成直方图汇总。

对于`I/O`压力较大的系统来说，第2至第4步会带来**较高的性能开销**。设想每秒传输10,000条磁盘`I/O`跟踪记录到用户空间并逐条解析，开销是极其巨大的。

使用`BPF`后的优化流程：

1.  **在内核中**：启用磁盘`I/O`事件，并附加一个由`bitesize`定义的自定义`BPF`程序。
2.  **每次事件发生时**：`BPF`程序在内核中运行，仅提取`bytes`字段，并将其写入自定义的`BPF`映射（`map`）作为直方图数据结构。
3.  **在用户空间**：只需一次性读取`BPF`映射中的直方图数据并输出即可。

这种方法完全避免了将事件逐条复制到用户空间并重新处理的高昂代价。同时，也避免了复制那些不被使用的元数据字段。最终，**唯一复制到用户空间的数据就是直方图中的“计数列”（count column），即一组数字数组**，这就是我们在工具输出中看到的内容。

###### 🍃 `BPF`与内核模块的对比

理解`BPF`在可观测性（`observability`）方面的优势，还有一种方法是将它与内核模块进行对比。事实上，`kprobes`和`tracepoints`早已在内核中存在多年，它们可以直接通过可加载内核模块（`LKM`）来使用。但相比之下，`BPF`在追踪分析中的优势包括：

-   **安全性更高**：`BPF`程序会经过`verifier`验证器的检查，而内核模块可能引入内核崩溃（`kernel panic`）或安全漏洞。

-   **支持丰富的数据结构**：`BPF`提供了结构化的`map`数据结构，便于存储与传递观测数据。

-   **良好的可移植性**：`BPF`程序可以一次编译，到处运行。因为`BPF`的指令集、`map`、`helper`函数和运行环境构成了一个稳定的 `ABI`（应用二进制接口）。

    >   （不过，需要注意的是，有些`BPF`跟踪程序仍依赖于不稳定的部分，比如基于内核结构体的`kprobe`，第2.3.10节会介绍相关解决方案。）

-   **无需依赖内核源码或构建产物**：`BPF`程序编译时不需要内核构建环境，降低了使用门槛。

-   **学习成本低**：`BPF`编程比编写内核模块更容易掌握，不需要深厚的内核开发经验，因此对更多开发者友好。

此外，`BPF`在网络方面还具备更多优势，比如支持**原子性替换**（`atomic replacement`）`BPF`程序。相比之下，内核模块想要升级代码，需要先卸载旧模块再重新加载新模块，这个过程可能会中断服务。

当然，内核模块的一个优势在于它能访问其他内核函数与功能，不受限于`BPF helper`调用。但这种灵活性也伴随着风险：如果调用了不当的内核函数，容易引入系统级别的`bug`。

### 2.3.3 编写 BPF 程序（润色翻译）

BPF 支持多种前端工具来进行编程。针对追踪用途，常见的从低到高层次的编程方式包括：

-   **LLVM**
-   **BCC**
-   **bpftrace**

LLVM 编译器支持将程序编译为 BPF 指令。开发者可以使用 LLVM 支持的高级语言（如 C，通过 Clang 编译）或 LLVM 中间表示（IR）来编写 BPF 程序，然后编译生成 BPF 字节码。LLVM 编译器还带有优化器，可提升生成的 BPF 程序的效率和紧凑性。

尽管直接用 LLVM IR 编写 BPF 程序已经是一种进步，但更推荐使用更高级的工具如 BCC 或 bpftrace：

-   **BCC** 允许使用 C 语言来编写 BPF 程序；
-   **bpftrace** 则提供了一种专用的高级脚本语言。

这两者在内部仍然依赖 LLVM IR 及其编译库将代码编译为 BPF 字节码。

本书所介绍的性能分析工具，主要基于 **BCC** 和 **bpftrace** 开发。直接使用 BPF 指令或 LLVM IR 进行编程，一般是 **BCC** 和 **bpftrace** 开发者的工作范畴，超出了本书的讨论范围。
 对于我们这些使用和开发 BPF 性能工具的人而言，了解底层 BPF 指令并非必要。

不过，如果你想深入成为 BPF 字节码开发者，或对底层实现感兴趣，可以参考以下资料：

-   附录 E 简要介绍了 BPF 的指令集和宏。
-   Linux 内核源码树中的文档 `Documentation/networking/filter.txt` 提供了 BPF 指令的详细说明。
-   LLVM IR 可通过 LLVM 官网的 [llvm::IRBuilderBase 类参考文档][18] 进行学习。
-   [Cilium 的 BPF 与 XDP 参考指南][19] 也提供了丰富的实践资料。

尽管我们大多数人不会直接编写 BPF 指令，但在排查工具问题时，我们常常会查看这些底层内容。接下来的两个小节将展示如何使用 `bpftool(8)` 和 `bpftrace` 来查看和调试 BPF 程序。